diff --git a/ale/liblocal/SDL-1.2.15/src/audio/baudio/SDL_beaudio.cc b/ale/liblocal/SDL-1.2.15/src/audio/baudio/SDL_beaudio.cc
deleted file mode 100644
index de635f8..0000000
--- a/ale/liblocal/SDL-1.2.15/src/audio/baudio/SDL_beaudio.cc
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-/* Allow access to the audio stream on BeOS */
-
-#include <SoundPlayer.h>
-
-#include "../../main/beos/SDL_BeApp.h"
-
-extern "C" {
-
-#include "SDL_audio.h"
-#include "../SDL_audio_c.h"
-#include "../SDL_sysaudio.h"
-#include "../../thread/beos/SDL_systhread_c.h"
-#include "SDL_beaudio.h"
-
-
-/* Audio driver functions */
-static int BE_OpenAudio(_THIS, SDL_AudioSpec *spec);
-static void BE_WaitAudio(_THIS);
-static void BE_PlayAudio(_THIS);
-static Uint8 *BE_GetAudioBuf(_THIS);
-static void BE_CloseAudio(_THIS);
-
-/* Audio driver bootstrap functions */
-
-static int Audio_Available(void)
-{
-	return(1);
-}
-
-static void Audio_DeleteDevice(SDL_AudioDevice *device)
-{
-	SDL_free(device->hidden);
-	SDL_free(device);
-}
-
-static SDL_AudioDevice *Audio_CreateDevice(int devindex)
-{
-	SDL_AudioDevice *device;
-
-	/* Initialize all variables that we clean on shutdown */
-	device = (SDL_AudioDevice *)SDL_malloc(sizeof(SDL_AudioDevice));
-	if ( device ) {
-		SDL_memset(device, 0, (sizeof *device));
-		device->hidden = (struct SDL_PrivateAudioData *)
-				SDL_malloc((sizeof *device->hidden));
-	}
-	if ( (device == NULL) || (device->hidden == NULL) ) {
-		SDL_OutOfMemory();
-		if ( device ) {
-			SDL_free(device);
-		}
-		return(0);
-	}
-	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
-
-	/* Set the function pointers */
-	device->OpenAudio = BE_OpenAudio;
-	device->WaitAudio = BE_WaitAudio;
-	device->PlayAudio = BE_PlayAudio;
-	device->GetAudioBuf = BE_GetAudioBuf;
-	device->CloseAudio = BE_CloseAudio;
-
-	device->free = Audio_DeleteDevice;
-
-	return device;
-}
-
-AudioBootStrap BAUDIO_bootstrap = {
-	"baudio", "BeOS BSoundPlayer",
-	Audio_Available, Audio_CreateDevice
-};
-
-/* The BeOS callback for handling the audio buffer */
-static void FillSound(void *device, void *stream, size_t len, 
-					const media_raw_audio_format &format)
-{
-	SDL_AudioDevice *audio = (SDL_AudioDevice *)device;
-
-	/* Silence the buffer, since it's ours */
-	SDL_memset(stream, audio->spec.silence, len);
-
-	/* Only do soemthing if audio is enabled */
-	if ( ! audio->enabled )
-		return;
-
-	if ( ! audio->paused ) {
-		if ( audio->convert.needed ) {
-			SDL_mutexP(audio->mixer_lock);
-			(*audio->spec.callback)(audio->spec.userdata,
-				(Uint8 *)audio->convert.buf,audio->convert.len);
-			SDL_mutexV(audio->mixer_lock);
-			SDL_ConvertAudio(&audio->convert);
-			SDL_memcpy(stream,audio->convert.buf,audio->convert.len_cvt);
-		} else {
-			SDL_mutexP(audio->mixer_lock);
-			(*audio->spec.callback)(audio->spec.userdata,
-						(Uint8 *)stream, len);
-			SDL_mutexV(audio->mixer_lock);
-		}
-	}
-	return;
-}
-
-/* Dummy functions -- we don't use thread-based audio */
-void BE_WaitAudio(_THIS)
-{
-	return;
-}
-void BE_PlayAudio(_THIS)
-{
-	return;
-}
-Uint8 *BE_GetAudioBuf(_THIS)
-{
-	return(NULL);
-}
-
-void BE_CloseAudio(_THIS)
-{
-	if ( audio_obj ) {
-		audio_obj->Stop();
-		delete audio_obj;
-		audio_obj = NULL;
-	}
-
-	/* Quit the Be Application, if there's nothing left to do */
-	SDL_QuitBeApp();
-}
-
-int BE_OpenAudio(_THIS, SDL_AudioSpec *spec)
-{
-    int valid_datatype = 0;
-    media_raw_audio_format format;
-    Uint16 test_format = SDL_FirstAudioFormat(spec->format);
-
-    /* Parse the audio format and fill the Be raw audio format */
-    memset(&format, '\0', sizeof (media_raw_audio_format));
-    format.byte_order = B_MEDIA_LITTLE_ENDIAN;
-    format.frame_rate = (float) spec->freq;
-    format.channel_count = spec->channels;  /* !!! FIXME: support > 2? */
-    while ((!valid_datatype) && (test_format)) {
-        valid_datatype = 1;
-        spec->format = test_format;
-        switch (test_format) {
-            case AUDIO_S8:
-                format.format = media_raw_audio_format::B_AUDIO_CHAR;
-                break;
-
-            case AUDIO_U8:
-                format.format = media_raw_audio_format::B_AUDIO_UCHAR;
-                break;
-
-            case AUDIO_S16LSB:
-                format.format = media_raw_audio_format::B_AUDIO_SHORT;
-                break;
-
-            case AUDIO_S16MSB:
-                format.format = media_raw_audio_format::B_AUDIO_SHORT;
-                format.byte_order = B_MEDIA_BIG_ENDIAN;
-                break;
-
-            default:
-                valid_datatype = 0;
-                test_format = SDL_NextAudioFormat();
-                break;
-        }
-    }
-
-    if (!valid_datatype) { /* shouldn't happen, but just in case... */
-        SDL_SetError("Unsupported audio format");
-        return (-1);
-    }
-
-    /* Initialize the Be Application, if it's not already started */
-    if (SDL_InitBeApp() < 0) {
-        return (-1);
-    }
-
-    format.buffer_size = spec->samples;
-
-	/* Calculate the final parameters for this audio specification */
-	SDL_CalculateAudioSpec(spec);
-
-	/* Subscribe to the audio stream (creates a new thread) */
-	{ sigset_t omask;
-		SDL_MaskSignals(&omask);
-		audio_obj = new BSoundPlayer(&format, "SDL Audio", FillSound,
-		                                                 NULL, _this);
-		SDL_UnmaskSignals(&omask);
-	}
-	if ( audio_obj->Start() == B_NO_ERROR ) {
-		audio_obj->SetHasData(true);
-	} else {
-		SDL_SetError("Unable to start Be audio");
-		return(-1);
-	}
-
-	/* We're running! */
-	return(1);
-}
-
-};	/* Extern C */
diff --git a/ale/liblocal/SDL-1.2.15/src/cdrom/beos/SDL_syscdrom.cc b/ale/liblocal/SDL-1.2.15/src/cdrom/beos/SDL_syscdrom.cc
deleted file mode 100644
index 9a62c38..0000000
--- a/ale/liblocal/SDL-1.2.15/src/cdrom/beos/SDL_syscdrom.cc
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#ifdef SDL_CDROM_BEOS
-
-/* Functions for system-level CD-ROM audio control on BeOS
-   (not completely implemented yet)
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <scsi.h>
-#include <Directory.h>
-#include <Entry.h>
-#include <Path.h>
-
-#include "SDL_cdrom.h"
-extern "C" {
-#include "../SDL_syscdrom.h"
-}
-
-/* Constants to help us get at the SCSI table-of-contents info */
-#define CD_NUMTRACKS(toc)	toc.toc_data[3]
-#define CD_TRACK(toc, track)	(&toc.toc_data[6+(track)*8])
-#define CD_TRACK_N(toc, track)	CD_TRACK(toc, track)[0]
-#define CD_TRACK_M(toc, track)	CD_TRACK(toc, track)[3]
-#define CD_TRACK_S(toc, track)	CD_TRACK(toc, track)[4]
-#define CD_TRACK_F(toc, track)	CD_TRACK(toc, track)[5]
-
-/* Constants to help us get at the SCSI position info */
-#define POS_TRACK(pos)	pos.position[6]
-#define POS_ABS_M(pos)	pos.position[9]
-#define POS_ABS_S(pos)	pos.position[10]
-#define POS_ABS_F(pos)	pos.position[11]
-#define POS_REL_M(pos)	pos.position[13]
-#define POS_REL_S(pos)	pos.position[14]
-#define POS_REL_F(pos)	pos.position[15]
-
-/* The maximum number of CD-ROM drives we'll detect */
-#define MAX_DRIVES	16	
-
-/* A list of available CD-ROM drives */
-static char *SDL_cdlist[MAX_DRIVES];
-
-/* The system-dependent CD control functions */
-static const char *SDL_SYS_CDName(int drive);
-static int SDL_SYS_CDOpen(int drive);
-static int SDL_SYS_CDGetTOC(SDL_CD *cdrom);
-static CDstatus SDL_SYS_CDStatus(SDL_CD *cdrom, int *position);
-static int SDL_SYS_CDPlay(SDL_CD *cdrom, int start, int length);
-static int SDL_SYS_CDPause(SDL_CD *cdrom);
-static int SDL_SYS_CDResume(SDL_CD *cdrom);
-static int SDL_SYS_CDStop(SDL_CD *cdrom);
-static int SDL_SYS_CDEject(SDL_CD *cdrom);
-static void SDL_SYS_CDClose(SDL_CD *cdrom);
-int try_dir(const char *directory);
-
-
-/* Check a drive to see if it is a CD-ROM */
-static int CheckDrive(char *drive)
-{
-	struct stat stbuf;
-	int is_cd, cdfd;
-	device_geometry info;
-
-	/* If it doesn't exist, return -1 */
-	if ( stat(drive, &stbuf) < 0 ) {
-		return(-1);
-	}
-
-	/* If it does exist, verify that it's an available CD-ROM */
-	is_cd = 0;
-	cdfd = open(drive, 0);
-	if ( cdfd >= 0 ) {
-		if ( ioctl(cdfd, B_GET_GEOMETRY, &info) == B_NO_ERROR ) {
-			if ( info.device_type == B_CD ) {
-				is_cd = 1;
-			}
-		}
-		close(cdfd);
-	} else {
-		/* This can happen when the drive is open .. (?) */;
-		is_cd = 1;
-	}
-	return(is_cd);
-}
-
-/* Add a CD-ROM drive to our list of valid drives */
-static void AddDrive(char *drive)
-{
-	int i;
-	size_t len;
-
-	if ( SDL_numcds < MAX_DRIVES ) {
-		/* Add this drive to our list */
-		i = SDL_numcds;
-		len = SDL_strlen(drive)+1;
-		SDL_cdlist[i] = (char *)SDL_malloc(len);
-		if ( SDL_cdlist[i] == NULL ) {
-			SDL_OutOfMemory();
-			return;
-		}
-		SDL_strlcpy(SDL_cdlist[i], drive, len);
-		++SDL_numcds;
-#ifdef CDROM_DEBUG
-  fprintf(stderr, "Added CD-ROM drive: %s\n", drive);
-#endif
-	}
-}
-
-/* IDE bus scanning magic */
-enum {
-	IDE_GET_DEVICES_INFO = B_DEVICE_OP_CODES_END + 50,
-};
-struct ide_ctrl_info {
-	bool	ide_0_present;
-	bool	ide_0_master_present;
-	bool	ide_0_slave_present;
-	int	ide_0_master_type;
-	int	ide_0_slave_type;
-	bool	ide_1_present;
-	bool	ide_1_master_present;
-	bool	ide_1_slave_present;
-	int	ide_1_master_type;
-	int	ide_1_slave_type;
-};
-
-int  SDL_SYS_CDInit(void)
-{
-	char *SDLcdrom;
-
-	/* Fill in our driver capabilities */
-	SDL_CDcaps.Name = SDL_SYS_CDName;
-	SDL_CDcaps.Open = SDL_SYS_CDOpen;
-	SDL_CDcaps.GetTOC = SDL_SYS_CDGetTOC;
-	SDL_CDcaps.Status = SDL_SYS_CDStatus;
-	SDL_CDcaps.Play = SDL_SYS_CDPlay;
-	SDL_CDcaps.Pause = SDL_SYS_CDPause;
-	SDL_CDcaps.Resume = SDL_SYS_CDResume;
-	SDL_CDcaps.Stop = SDL_SYS_CDStop;
-	SDL_CDcaps.Eject = SDL_SYS_CDEject;
-	SDL_CDcaps.Close = SDL_SYS_CDClose;
-
-	/* Look in the environment for our CD-ROM drive list */
-	SDLcdrom = SDL_getenv("SDL_CDROM");	/* ':' separated list of devices */
-	if ( SDLcdrom != NULL ) {
-		char *cdpath, *delim;
-		size_t len = SDL_strlen(SDLcdrom)+1;
-		cdpath = SDL_stack_alloc(char, len);
-		if ( cdpath != NULL ) {
-			SDL_strlcpy(cdpath, SDLcdrom, len);
-			SDLcdrom = cdpath;
-			do {
-				delim = SDL_strchr(SDLcdrom, ':');
-				if ( delim ) {
-					*delim++ = '\0';
-				}
-				if ( CheckDrive(SDLcdrom) > 0 ) {
-					AddDrive(SDLcdrom);
-				}
-				if ( delim ) {
-					SDLcdrom = delim;
-				} else {
-					SDLcdrom = NULL;
-				}
-			} while ( SDLcdrom );
-			SDL_stack_free(cdpath);
-		}
-
-		/* If we found our drives, there's nothing left to do */
-		if ( SDL_numcds > 0 ) {
-			return(0);
-		}
-	}
-	
-	/* Scan the system for CD-ROM drives */
-	try_dir("/dev/disk");
-	return 0;
-}
-
-
-int try_dir(const char *directory)
-{ 
-	BDirectory dir; 
-	dir.SetTo(directory); 
-	if(dir.InitCheck() != B_NO_ERROR) { 
-		return false; 
-	} 
-	dir.Rewind(); 
-	BEntry entry; 
-	while(dir.GetNextEntry(&entry) >= 0) { 
-		BPath path; 
-		const char *name; 
-		entry_ref e; 
-		
-		if(entry.GetPath(&path) != B_NO_ERROR) 
-			continue; 
-		name = path.Path(); 
-		
-		if(entry.GetRef(&e) != B_NO_ERROR) 
-			continue; 
-
-		if(entry.IsDirectory()) { 
-			if(SDL_strcmp(e.name, "floppy") == 0) 
-				continue; /* ignore floppy (it is not silent)  */
-			int devfd = try_dir(name);
-			if(devfd >= 0)
-				return devfd;
-		} 
-		else { 
-			int devfd; 
-			device_geometry g; 
-
-			if(SDL_strcmp(e.name, "raw") != 0) 
-				continue; /* ignore partitions */
-
-			devfd = open(name, O_RDONLY); 
-			if(devfd < 0) 
-				continue; 
-
-			if(ioctl(devfd, B_GET_GEOMETRY, &g, sizeof(g)) >= 0) {
-				if(g.device_type == B_CD)
-				{
-				AddDrive(strdup(name));
-				}
-			}
-			close(devfd);
-		} 
-	}
-	return B_ERROR;
-}
-
-
-/* General ioctl() CD-ROM command function */
-static int SDL_SYS_CDioctl(int index, int command, void *arg)
-{
-	int okay;
-	int fd;
-
-	okay = 0;
-	fd = open(SDL_cdlist[index], 0);
-	if ( fd >= 0 ) {
-		if ( ioctl(fd, command, arg) == B_NO_ERROR ) {
-			okay = 1;
-		}
-		close(fd);
-	}
-	return(okay ? 0 : -1);
-}
-
-static const char *SDL_SYS_CDName(int drive)
-{
-	return(SDL_cdlist[drive]);
-} 
-
-static int SDL_SYS_CDOpen(int drive)
-{
-	return(drive);
-}
-
-static int SDL_SYS_CDGetTOC(SDL_CD *cdrom)
-{
-	int i;
-	scsi_toc toc;
-
-	if ( SDL_SYS_CDioctl(cdrom->id, B_SCSI_GET_TOC, &toc) == 0 ) {
-		cdrom->numtracks = CD_NUMTRACKS(toc);
-		if ( cdrom->numtracks > SDL_MAX_TRACKS ) {
-			cdrom->numtracks = SDL_MAX_TRACKS;
-		}
-		for ( i=0; i<=cdrom->numtracks; ++i ) {
-			cdrom->track[i].id = CD_TRACK_N(toc, i);
-			/* FIXME:  How do we tell on BeOS? */
-			cdrom->track[i].type = SDL_AUDIO_TRACK;
-			cdrom->track[i].offset = MSF_TO_FRAMES(
-							CD_TRACK_M(toc, i),
-							CD_TRACK_S(toc, i),
-							CD_TRACK_F(toc, i));
-			cdrom->track[i].length = 0;
-			if ( i > 0 ) {
-				cdrom->track[i-1].length =
-						cdrom->track[i].offset-
-						cdrom->track[i-1].offset;
-			}
-		}
-		return(0);
-	} else {
-		return(-1);
-	}
-}
-
-/* Get CD-ROM status */
-static CDstatus SDL_SYS_CDStatus(SDL_CD *cdrom, int *position)
-{
-	CDstatus status;
-	int fd;
-	int cur_frame;
-	scsi_position pos;
-
-	fd = open(SDL_cdlist[cdrom->id], 0);
-	cur_frame = 0;
-	if ( fd >= 0 ) {
-		if ( ioctl(fd, B_SCSI_GET_POSITION, &pos) == B_NO_ERROR ) {
-			cur_frame = MSF_TO_FRAMES(
-				POS_ABS_M(pos), POS_ABS_S(pos), POS_ABS_F(pos));
-		}
-		if ( ! pos.position[1] || (pos.position[1] >= 0x13) ||
-			((pos.position[1] == 0x12) && (!pos.position[6])) ) {
-			status = CD_STOPPED;
-		} else
-		if ( pos.position[1] == 0x11 ) {
-			status = CD_PLAYING;
-		} else {
-			status = CD_PAUSED;
-		}
-		close(fd);
-	} else {
-		status = CD_TRAYEMPTY;
-	}
-	if ( position ) {
-		*position = cur_frame;
-	}
-	return(status);
-}
-
-/* Start play */
-static int SDL_SYS_CDPlay(SDL_CD *cdrom, int start, int length)
-{
-	int okay;
-	int fd;
-	scsi_play_position pos;
-
-	okay = 0;
-	fd = open(SDL_cdlist[cdrom->id], 0);
-	if ( fd >= 0 ) {
-		FRAMES_TO_MSF(start, &pos.start_m, &pos.start_s, &pos.start_f);
-		FRAMES_TO_MSF(start+length, &pos.end_m, &pos.end_s, &pos.end_f);
-		if ( ioctl(fd, B_SCSI_PLAY_POSITION, &pos) == B_NO_ERROR ) {
-			okay = 1;
-		}
-		close(fd);
-	}
-	return(okay ? 0 : -1);
-}
-
-/* Pause play */
-static int SDL_SYS_CDPause(SDL_CD *cdrom)
-{
-	return(SDL_SYS_CDioctl(cdrom->id, B_SCSI_PAUSE_AUDIO, 0));
-}
-
-/* Resume play */
-static int SDL_SYS_CDResume(SDL_CD *cdrom)
-{
-	return(SDL_SYS_CDioctl(cdrom->id, B_SCSI_RESUME_AUDIO, 0));
-}
-
-/* Stop play */
-static int SDL_SYS_CDStop(SDL_CD *cdrom)
-{
-	return(SDL_SYS_CDioctl(cdrom->id, B_SCSI_STOP_AUDIO, 0));
-}
-
-/* Eject the CD-ROM */
-static int SDL_SYS_CDEject(SDL_CD *cdrom)
-{
-	return(SDL_SYS_CDioctl(cdrom->id, B_SCSI_EJECT, 0));
-}
-
-/* Close the CD-ROM handle */
-static void SDL_SYS_CDClose(SDL_CD *cdrom)
-{
-	close(cdrom->id);
-}
-
-void SDL_SYS_CDQuit(void)
-{
-	int i;
-
-	if ( SDL_numcds > 0 ) {
-		for ( i=0; i<SDL_numcds; ++i ) {
-			SDL_free(SDL_cdlist[i]);
-		}
-		SDL_numcds = 0;
-	}
-}
-
-#endif /* SDL_CDROM_BEOS */
diff --git a/ale/liblocal/SDL-1.2.15/src/joystick/beos/SDL_bejoystick.cc b/ale/liblocal/SDL-1.2.15/src/joystick/beos/SDL_bejoystick.cc
deleted file mode 100644
index af8a341..0000000
--- a/ale/liblocal/SDL-1.2.15/src/joystick/beos/SDL_bejoystick.cc
+++ /dev/null
@@ -1,237 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#ifdef SDL_JOYSTICK_BEOS
-
-/* This is the system specific header for the SDL joystick API */
-
-#include <be/support/String.h>
-#include <be/device/Joystick.h>
-
-extern "C" {
-
-#include "SDL_joystick.h"
-#include "../SDL_sysjoystick.h"
-#include "../SDL_joystick_c.h"
-
-
-/* The maximum number of joysticks we'll detect */
-#define MAX_JOYSTICKS	16	
-
-/* A list of available joysticks */
-static char *SDL_joyport[MAX_JOYSTICKS];
-static char *SDL_joyname[MAX_JOYSTICKS];
-
-/* The private structure used to keep track of a joystick */
-struct joystick_hwdata {
-	BJoystick *stick;
-	uint8 *new_hats;
-	int16 *new_axes;
-};
-
-/* Function to scan the system for joysticks.
- * This function should set SDL_numjoysticks to the number of available
- * joysticks.  Joystick 0 should be the system default joystick.
- * It should return 0, or -1 on an unrecoverable fatal error.
- */
-int SDL_SYS_JoystickInit(void)
-{
-	BJoystick joystick;
-	int numjoysticks;
-	int i;
-	int32 nports;
-	char name[B_OS_NAME_LENGTH];
-	
-	/* Search for attached joysticks */
-	nports = joystick.CountDevices();
-	numjoysticks = 0;
-	SDL_memset(SDL_joyport, 0, (sizeof SDL_joyport));
-	SDL_memset(SDL_joyname, 0, (sizeof SDL_joyname));
-	for ( i=0; (SDL_numjoysticks < MAX_JOYSTICKS) && (i < nports); ++i ) {
-		if ( joystick.GetDeviceName(i, name) == B_OK ) {
-			if ( joystick.Open(name) != B_ERROR ) {
-				BString stick_name;
-				joystick.GetControllerName(&stick_name);
-				SDL_joyport[numjoysticks] = strdup(name);
-				SDL_joyname[numjoysticks] =
-					           strdup(stick_name.String());
-				numjoysticks++;
-				joystick.Close();
-			}
-		}
-	}
-	return(numjoysticks);
-}
-
-/* Function to get the device-dependent name of a joystick */
-const char *SDL_SYS_JoystickName(int index)
-{
-	return SDL_joyname[index];
-}
-
-/* Function to open a joystick for use.
-   The joystick to open is specified by the index field of the joystick.
-   This should fill the nbuttons and naxes fields of the joystick structure.
-   It returns 0, or -1 if there is an error.
- */
-int SDL_SYS_JoystickOpen(SDL_Joystick *joystick)
-{
-	BJoystick *stick;
-
-	/* Create the joystick data structure */
-	joystick->hwdata = (struct joystick_hwdata *)
-	                   SDL_malloc(sizeof(*joystick->hwdata));
-	if ( joystick->hwdata == NULL ) {
-		SDL_OutOfMemory();
-		return(-1);
-	}
-	SDL_memset(joystick->hwdata, 0, sizeof(*joystick->hwdata));
-	stick = new BJoystick;
-	joystick->hwdata->stick = stick;
-
-	/* Open the requested joystick for use */
-	if ( stick->Open(SDL_joyport[joystick->index]) == B_ERROR ) {
-		SDL_SetError("Unable to open joystick");
-		SDL_SYS_JoystickClose(joystick);
-		return(-1);
-	}
-
-	/* Set the joystick to calibrated mode */
-	stick->EnableCalibration();
-
-	/* Get the number of buttons, hats, and axes on the joystick */
-	joystick->nbuttons = stick->CountButtons();
-	joystick->naxes = stick->CountAxes();
-	joystick->nhats = stick->CountHats();
-
-	joystick->hwdata->new_axes = (int16 *)
-	                  SDL_malloc(joystick->naxes*sizeof(int16));
-	joystick->hwdata->new_hats = (uint8 *)
-	                  SDL_malloc(joystick->nhats*sizeof(uint8));
-	if ( ! joystick->hwdata->new_hats || ! joystick->hwdata->new_axes ) {
-		SDL_OutOfMemory();
-		SDL_SYS_JoystickClose(joystick);
-		return(-1);
-	}
-
-	/* We're done! */
-	return(0);
-}
-
-/* Function to update the state of a joystick - called as a device poll.
- * This function shouldn't update the joystick structure directly,
- * but instead should call SDL_PrivateJoystick*() to deliver events
- * and update joystick device state.
- */
-void SDL_SYS_JoystickUpdate(SDL_Joystick *joystick)
-{
-	static const Uint8 hat_map[9] = {
-             SDL_HAT_CENTERED,
-             SDL_HAT_UP,
-             SDL_HAT_RIGHTUP,
-             SDL_HAT_RIGHT,
-             SDL_HAT_RIGHTDOWN,
-             SDL_HAT_DOWN,
-             SDL_HAT_LEFTDOWN,
-             SDL_HAT_LEFT,
-             SDL_HAT_LEFTUP
-	};
-	const int JITTER = (32768/10);	/* 10% jitter threshold (ok?) */
-
-	BJoystick *stick;
-	int i, change;
-	int16 *axes;
-	uint8 *hats;
-	uint32 buttons;
-
-	/* Set up data pointers */
-	stick = joystick->hwdata->stick;
-	axes = joystick->hwdata->new_axes;
-	hats = joystick->hwdata->new_hats;
-
-	/* Get the new joystick state */
-	stick->Update();
-	stick->GetAxisValues(axes);
-	stick->GetHatValues(hats);
-	buttons = stick->ButtonValues();
-
-	/* Generate axis motion events */
-	for ( i=0; i<joystick->naxes; ++i ) {
-		change = ((int32)axes[i] - joystick->axes[i]);
-		if ( (change > JITTER) || (change < -JITTER) ) {
-			SDL_PrivateJoystickAxis(joystick, i, axes[i]);
-		}
-	}
-
-	/* Generate hat change events */
-	for ( i=0; i<joystick->nhats; ++i ) {
-		if ( hats[i] != joystick->hats[i] ) {
-			SDL_PrivateJoystickHat(joystick, i, hat_map[hats[i]]);
-		}
-	}
-
-	/* Generate button events */
-	for ( i=0; i<joystick->nbuttons; ++i ) {
-		if ( (buttons&0x01) != joystick->buttons[i] ) {
-			SDL_PrivateJoystickButton(joystick, i, (buttons&0x01));
-		}
-		buttons >>= 1;
-	}
-}
-
-/* Function to close a joystick after use */
-void SDL_SYS_JoystickClose(SDL_Joystick *joystick)
-{
-	if ( joystick->hwdata ) {
-		joystick->hwdata->stick->Close();
-		delete joystick->hwdata->stick;
-		if ( joystick->hwdata->new_hats ) {
-			SDL_free(joystick->hwdata->new_hats);
-		}
-		if ( joystick->hwdata->new_axes ) {
-			SDL_free(joystick->hwdata->new_axes);
-		}
-		SDL_free(joystick->hwdata);
-		joystick->hwdata = NULL;
-	}
-}
-
-/* Function to perform any system-specific joystick related cleanup */
-void SDL_SYS_JoystickQuit(void)
-{
-	int i;
-
-	for ( i=0; SDL_joyport[i]; ++i ) {
-		SDL_free(SDL_joyport[i]);
-	}
-	SDL_joyport[0] = NULL;
-
-	for ( i=0; SDL_joyname[i]; ++i ) {
-		SDL_free(SDL_joyname[i]);
-	}
-	SDL_joyname[0] = NULL;
-}
-
-}; // extern "C"
-
-#endif /* SDL_JOYSTICK_BEOS */
diff --git a/ale/liblocal/SDL-1.2.15/src/main/beos/SDL_BeApp.cc b/ale/liblocal/SDL-1.2.15/src/main/beos/SDL_BeApp.cc
deleted file mode 100644
index 8b79377..0000000
--- a/ale/liblocal/SDL-1.2.15/src/main/beos/SDL_BeApp.cc
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-/* Handle the BeApp specific portions of the application */
-
-#include <AppKit.h>
-#include <storage/Path.h>
-#include <storage/Entry.h>
-#include <unistd.h>
-
-#include "SDL_BeApp.h"
-#include "SDL_thread.h"
-#include "SDL_timer.h"
-#include "SDL_error.h"
-
-/* Flag to tell whether or not the Be application is active or not */
-int SDL_BeAppActive = 0;
-static SDL_Thread *SDL_AppThread = NULL;
-
-static int StartBeApp(void *unused)
-{
-  if(!be_app) {
-	BApplication *App;
-
-	App = new BApplication("application/x-SDL-executable");
-
-	App->Run();
-	delete App;
-  }
- return(0);
-}
-
-/* Initialize the Be Application, if it's not already started */
-int SDL_InitBeApp(void)
-{
-	/* Create the BApplication that handles appserver interaction */
-	if ( SDL_BeAppActive <= 0 ) {
-		SDL_AppThread = SDL_CreateThread(StartBeApp, NULL);
-		if ( SDL_AppThread == NULL ) {
-			SDL_SetError("Couldn't create BApplication thread");
-			return(-1);
-		}
-		
-		/* Change working to directory to that of executable */
-		app_info info;
-		if (B_OK == be_app->GetAppInfo(&info)) {
-			entry_ref ref = info.ref;
-			BEntry entry;
-			if (B_OK == entry.SetTo(&ref)) {
-				BPath path;
-				if (B_OK == path.SetTo(&entry)) {
-					if (B_OK == path.GetParent(&path)) {
-						chdir(path.Path());
-					}
-				}
-			}
-		}	
-		
-		do {
-			SDL_Delay(10);
-		} while ( (be_app == NULL) || be_app->IsLaunching() );
-
-		/* Mark the application active */
-		SDL_BeAppActive = 0;
-	}
-
-	/* Increment the application reference count */
-	++SDL_BeAppActive;
-
-	/* The app is running, and we're ready to go */
- return(0);
-}
-
-/* Quit the Be Application, if there's nothing left to do */
-void SDL_QuitBeApp(void)
-{
-	/* Decrement the application reference count */
-	--SDL_BeAppActive;
-
-	/* If the reference count reached zero, clean up the app */
-	if ( SDL_BeAppActive == 0 ) {
-		if ( SDL_AppThread != NULL ) {
-			if ( be_app != NULL ) { /* Not tested */
-				be_app->PostMessage(B_QUIT_REQUESTED);
-			}
-			SDL_WaitThread(SDL_AppThread, NULL);
-			SDL_AppThread = NULL;
-		}
-		/* be_app should now be NULL since be_app has quit */
-	}
-}
diff --git a/ale/liblocal/SDL-1.2.15/src/main/qtopia/SDL_qtopia_main.cc b/ale/liblocal/SDL-1.2.15/src/main/qtopia/SDL_qtopia_main.cc
deleted file mode 100644
index 46fd518..0000000
--- a/ale/liblocal/SDL-1.2.15/src/main/qtopia/SDL_qtopia_main.cc
+++ /dev/null
@@ -1,47 +0,0 @@
-
-/* Include the SDL main definition header */
-#include "SDL_main.h"
-#include <stdlib.h>
-#include <unistd.h>
-#ifdef main
-#undef main
-#endif
-#ifdef QWS
-#include <qpe/qpeapplication.h>
-#include <qapplication.h>
-#include <qpe/qpeapplication.h>
-#include <stdlib.h>
-
-// Workaround for OPIE to remove taskbar icon. Also fixes
-// some issues in Qtopia where there are left-over qcop files in /tmp/.
-// I'm guessing this will also clean up the taskbar in the Sharp version
-// of Qtopia.
-static inline void cleanupQCop() {
-  QString appname(qApp->argv()[0]);
-  int slash = appname.findRev("/");
-  if(slash != -1) {  appname = appname.mid(slash+1); }
-  QString cmd = QPEApplication::qpeDir() + "bin/qcop QPE/System 'closing(QString)' '"+appname+"'";
-  system(cmd.latin1());
-  cmd = "/tmp/qcop-msg-"+appname;
-  unlink(cmd.latin1());
-}
-
-static QPEApplication *app;
-#endif
-
-extern int SDL_main(int argc, char *argv[]);
-
-int main(int argc, char *argv[])
-{
-#ifdef QWS
-  // This initializes the Qtopia application. It needs to be done here
-  // because it parses command line options.
-  app = new QPEApplication(argc, argv);
-  QWidget dummy;
-  app->showMainWidget(&dummy);
-  atexit(cleanupQCop);
-#endif
-  // Exit here because if return is used, the application
-  // doesn't seem to quit correctly.
-  exit(SDL_main(argc, argv));
-}
diff --git a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysevents.cc b/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysevents.cc
deleted file mode 100644
index 9e12750..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysevents.cc
+++ /dev/null
@@ -1,415 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include <support/UTF8.h>
-#include <stdio.h>
-#include <string.h>
-#include "SDL_error.h"
-#include "SDL_events.h"
-#include "SDL_BWin.h"
-#include "SDL_lowvideo.h"
-
-static SDLKey keymap[128];
-int mouse_relative = 0;
-extern "C" {
-
-#include "../../events/SDL_sysevents.h"
-#include "../../events/SDL_events_c.h"
-#include "SDL_sysevents_c.h"
-#include "../SDL_cursor_c.h"
-
-void BE_PumpEvents(_THIS)
-{
-}
-
-void BE_InitOSKeymap(_THIS)
-{
-		for ( uint i=0; i<SDL_TABLESIZE(keymap); ++i )
-			keymap[i] = SDLK_UNKNOWN;
-
-		keymap[0x01]		= SDLK_ESCAPE;
-		keymap[B_F1_KEY]	= SDLK_F1;
-		keymap[B_F2_KEY]	= SDLK_F2;
-		keymap[B_F3_KEY]	= SDLK_F3;
-		keymap[B_F4_KEY]	= SDLK_F4;
-		keymap[B_F5_KEY]	= SDLK_F5;
-		keymap[B_F6_KEY]	= SDLK_F6;
-		keymap[B_F7_KEY]	= SDLK_F7;
-		keymap[B_F8_KEY]	= SDLK_F8;
-		keymap[B_F9_KEY]	= SDLK_F9;
-		keymap[B_F10_KEY]	= SDLK_F10;
-		keymap[B_F11_KEY]	= SDLK_F11;
-		keymap[B_F12_KEY]	= SDLK_F12;
-		keymap[B_PRINT_KEY]	= SDLK_PRINT;
-		keymap[B_SCROLL_KEY]	= SDLK_SCROLLOCK;
-		keymap[B_PAUSE_KEY]	= SDLK_PAUSE;
-		keymap[0x11]		= SDLK_BACKQUOTE;
-		keymap[0x12]		= SDLK_1;
-		keymap[0x13]		= SDLK_2;
-		keymap[0x14]		= SDLK_3;
-		keymap[0x15]		= SDLK_4;
-		keymap[0x16]		= SDLK_5;
-		keymap[0x17]		= SDLK_6;
-		keymap[0x18]		= SDLK_7;
-		keymap[0x19]		= SDLK_8;
-		keymap[0x1a]		= SDLK_9;
-		keymap[0x1b]		= SDLK_0;
-		keymap[0x1c]		= SDLK_MINUS;
-		keymap[0x1d]		= SDLK_EQUALS;
-		keymap[0x1e]		= SDLK_BACKSPACE;
-		keymap[0x1f]		= SDLK_INSERT;
-		keymap[0x20]		= SDLK_HOME;
-		keymap[0x21]		= SDLK_PAGEUP;
-		keymap[0x22]		= SDLK_NUMLOCK;
-		keymap[0x23]		= SDLK_KP_DIVIDE;
-		keymap[0x24]		= SDLK_KP_MULTIPLY;
-		keymap[0x25]		= SDLK_KP_MINUS;
-		keymap[0x26]		= SDLK_TAB;
-		keymap[0x27]		= SDLK_q;
-		keymap[0x28]		= SDLK_w;
-		keymap[0x29]		= SDLK_e;
-		keymap[0x2a]		= SDLK_r;
-		keymap[0x2b]		= SDLK_t;
-		keymap[0x2c]		= SDLK_y;
-		keymap[0x2d]		= SDLK_u;
-		keymap[0x2e]		= SDLK_i;
-		keymap[0x2f]		= SDLK_o;
-		keymap[0x30]		= SDLK_p;
-		keymap[0x31]		= SDLK_LEFTBRACKET;
-		keymap[0x32]		= SDLK_RIGHTBRACKET;
-		keymap[0x33]		= SDLK_BACKSLASH;
-		keymap[0x34]		= SDLK_DELETE;
-		keymap[0x35]		= SDLK_END;
-		keymap[0x36]		= SDLK_PAGEDOWN;
-		keymap[0x37]		= SDLK_KP7;
-		keymap[0x38]		= SDLK_KP8;
-		keymap[0x39]		= SDLK_KP9;
-		keymap[0x3a]		= SDLK_KP_PLUS;
-		keymap[0x3b]		= SDLK_CAPSLOCK;
-		keymap[0x3c]		= SDLK_a;
-		keymap[0x3d]		= SDLK_s;
-		keymap[0x3e]		= SDLK_d;
-		keymap[0x3f]		= SDLK_f;
-		keymap[0x40]		= SDLK_g;
-		keymap[0x41]		= SDLK_h;
-		keymap[0x42]		= SDLK_j;
-		keymap[0x43]		= SDLK_k;
-		keymap[0x44]		= SDLK_l;
-		keymap[0x45]		= SDLK_SEMICOLON;
-		keymap[0x46]		= SDLK_QUOTE;
-		keymap[0x47]		= SDLK_RETURN;
-		keymap[0x48]		= SDLK_KP4;
-		keymap[0x49]		= SDLK_KP5;
-		keymap[0x4a]		= SDLK_KP6;
-		keymap[0x4b]		= SDLK_LSHIFT;
-		keymap[0x4c]		= SDLK_z;
-		keymap[0x4d]		= SDLK_x;
-		keymap[0x4e]		= SDLK_c;
-		keymap[0x4f]		= SDLK_v;
-		keymap[0x50]		= SDLK_b;
-		keymap[0x51]		= SDLK_n;
-		keymap[0x52]		= SDLK_m;
-		keymap[0x53]		= SDLK_COMMA;
-		keymap[0x54]		= SDLK_PERIOD;
-		keymap[0x55]		= SDLK_SLASH;
-		keymap[0x56]		= SDLK_RSHIFT;
-		keymap[0x57]		= SDLK_UP;
-		keymap[0x58]		= SDLK_KP1;
-		keymap[0x59]		= SDLK_KP2;
-		keymap[0x5a]		= SDLK_KP3;
-		keymap[0x5b]		= SDLK_KP_ENTER;
-		keymap[0x5c]		= SDLK_LCTRL;
-		keymap[0x5d]		= SDLK_LALT;
-		keymap[0x5e]		= SDLK_SPACE;
-		keymap[0x5f]		= SDLK_RALT;
-		keymap[0x60]		= SDLK_RCTRL;
-		keymap[0x61]		= SDLK_LEFT;
-		keymap[0x62]		= SDLK_DOWN;
-		keymap[0x63]		= SDLK_RIGHT;
-		keymap[0x64]		= SDLK_KP0;
-		keymap[0x65]		= SDLK_KP_PERIOD;
-		keymap[0x66]		= SDLK_LMETA;
-		keymap[0x67]		= SDLK_RMETA;
-		keymap[0x68]		= SDLK_MENU;
-		keymap[0x69]		= SDLK_EURO;
-		keymap[0x6a]		= SDLK_KP_EQUALS;
-		keymap[0x6b]		= SDLK_POWER;
-}
-
-}; /* Extern C */
-
-void SDL_BWin::DispatchMessage(BMessage *msg, BHandler *target)
-{
-	switch (msg->what) {
-		case B_MOUSE_MOVED:
-		{
-			SDL_VideoDevice *view = current_video;
-			BPoint where;
-			int32 transit;
-			if (msg->FindPoint("where", &where) == B_OK && msg->FindInt32("be:transit", &transit) == B_OK) {
-				int x, y;
-
-				GetXYOffset(x, y);
-				x = (int)where.x - x;
-				y = (int)where.y - y;
-
-				//BeSman: I need another method for cursor catching !!!
-				if (view->input_grab != SDL_GRAB_OFF)
-				{
-					bool clipped = false;
-					if ( x < 0 ) {
-						x = 0;
-						clipped = true;
-					} else if ( x >= SDL_VideoSurface->w ) {
-						x = (SDL_VideoSurface->w-1);
-						clipped = true;
-					}
-					if ( y < 0 ) {
-						y = 0;
-						clipped = true;
-					} else if ( y >= SDL_VideoSurface->h ) {
-						y = (SDL_VideoSurface->h-1);
-						clipped = true;
-					}
-					if ( clipped ) {
-						BPoint edge;
-						GetXYOffset(edge.x, edge.y);
-						edge.x += x;
-						edge.y += y;
-						ConvertToScreen(&edge);
-						set_mouse_position((int)edge.x, (int)edge.y);
-					}
-					transit = B_INSIDE_VIEW;
-				}
-				if (transit == B_EXITED_VIEW) {
-					if ( SDL_GetAppState() & SDL_APPMOUSEFOCUS ) {
-						SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
-#if SDL_VIDEO_OPENGL
-					// for some reason, SDL_EraseCursor fails for OpenGL
-					if (this->the_view != this->SDL_GLView)
-#endif
-							SDL_EraseCursor(SDL_VideoSurface);
-						be_app->SetCursor(B_HAND_CURSOR);
-					}
-				} else {
-					if ( !(SDL_GetAppState() & SDL_APPMOUSEFOCUS) ) {
-						SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
-#if SDL_VIDEO_OPENGL
-					// for some reason, SDL_EraseCursor fails for OpenGL
-					if (this->the_view != this->SDL_GLView)
-#endif
-							SDL_EraseCursor(SDL_VideoSurface);
-						SDL_SetCursor(NULL);
-					}
-
-					if ( mouse_relative ) {
-						int half_w = (SDL_VideoSurface->w/2);
-						int half_h = (SDL_VideoSurface->h/2);
-						x -= half_w;
-						y -= half_h;
-						if ( x || y ) {
-							BPoint center;
-							GetXYOffset(center.x, center.y);
-							center.x += half_w;
-							center.y += half_h;
-							ConvertToScreen(&center);
-							set_mouse_position((int)center.x, (int)center.y);
-							SDL_PrivateMouseMotion(0, 1, x, y);
-						}
-					} else {
-						SDL_PrivateMouseMotion(0, 0, x, y);
-					}
-				}
-			}
-			break;
-		}
-
-		case B_MOUSE_DOWN:
-		{
-			/*	it looks like mouse down is send only for first clicked
-				button, each next is not send while last one is holded */
-			int32 buttons;
-			int sdl_buttons = 0;
-			if (msg->FindInt32("buttons", &buttons) == B_OK) {
-				/* Add any mouse button events */
-				if (buttons & B_PRIMARY_MOUSE_BUTTON) {
-					sdl_buttons |= SDL_BUTTON_LEFT;
-				}
-				if (buttons & B_SECONDARY_MOUSE_BUTTON) {
-					sdl_buttons |= SDL_BUTTON_RIGHT;
-				}
-				if (buttons & B_TERTIARY_MOUSE_BUTTON) {
-					sdl_buttons |= SDL_BUTTON_MIDDLE;
-				}
-				SDL_PrivateMouseButton(SDL_PRESSED, sdl_buttons, 0, 0);
-
-				last_buttons = buttons;
-			}
-			break;
-		}
-
-		case B_MOUSE_UP:
-		{
-			/*	mouse up doesn't give which button was released,
-				only state of buttons (after release, so it's always = 0),
-				which is not what we need ;]
-				So we need to store button in mouse down, and restore
-				in mouse up :(
-				mouse up is (similarly to mouse down) send only for
-				first button down (ie. it's no send if we click another button
-				without releasing previous one first) - but that's probably
-				because of how drivers are written?, not BeOS itself. */
-			int32 buttons;
-			int sdl_buttons = 0;
-			if (msg->FindInt32("buttons", &buttons) == B_OK) {
-				/* Add any mouse button events */
-				if ((buttons ^ B_PRIMARY_MOUSE_BUTTON) & last_buttons) {
-					sdl_buttons |= SDL_BUTTON_LEFT;
-				}
-				if ((buttons ^ B_SECONDARY_MOUSE_BUTTON) & last_buttons) {
-					sdl_buttons |= SDL_BUTTON_RIGHT;
-				}
-				if ((buttons ^ B_TERTIARY_MOUSE_BUTTON) & last_buttons) {
-					sdl_buttons |= SDL_BUTTON_MIDDLE;
-				}
-				SDL_PrivateMouseButton(SDL_RELEASED, sdl_buttons, 0, 0);
-
-				last_buttons = buttons;
-			}
-			break;
-		}
-
-		case B_MOUSE_WHEEL_CHANGED:
-		{
-			float x, y;
-			x = y = 0;
-			if (msg->FindFloat("be:wheel_delta_x", &x) == B_OK && msg->FindFloat("be:wheel_delta_y", &y) == B_OK) {
-				if (x < 0 || y < 0) {
-					SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELDOWN, 0, 0);
-					SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELDOWN, 0, 0);
-				} else if (x > 0 || y > 0) {
-					SDL_PrivateMouseButton(SDL_PRESSED, SDL_BUTTON_WHEELUP, 0, 0);
-					SDL_PrivateMouseButton(SDL_RELEASED, SDL_BUTTON_WHEELUP, 0, 0);
-				}
-			}
-			break;
-		}
-
-		case B_KEY_DOWN:
-		case B_UNMAPPED_KEY_DOWN: /* modifier keys are unmapped */
-		{
-			int32 key;
-			int32 modifiers;
-			int32 key_repeat;
-			/* Workaround for SDL message queue being filled too fast because of BeOS own key-repeat mechanism */
-			if (msg->FindInt32("be:key_repeat", &key_repeat) == B_OK && key_repeat > 0)
-				break;
-
-			if (msg->FindInt32("key", &key) == B_OK && msg->FindInt32("modifiers", &modifiers) == B_OK) {
-				SDL_keysym keysym;
-				keysym.scancode = key;
-				if (key < 128) {
-					keysym.sym = keymap[key];
-				} else {
-					keysym.sym = SDLK_UNKNOWN;
-				}
-				/*	FIX THIS?
-					it seems SDL_PrivateKeyboard() changes mod value
-					anyway, and doesn't care about what we setup here */
-				keysym.mod = KMOD_NONE;
-				keysym.unicode = 0;
-				if (SDL_TranslateUNICODE) {
-					const char *bytes;
-					if (msg->FindString("bytes", &bytes) == B_OK) {
-						/*	FIX THIS?
-							this cares only about first "letter",
-							so if someone maps some key to print
-							"BeOS rulez!" only "B" will be used. */
-						keysym.unicode = Translate2Unicode(bytes);
-					}
-				}
-				SDL_PrivateKeyboard(SDL_PRESSED, &keysym);
-			}
-			break;
-		}
-
-		case B_KEY_UP:
-		case B_UNMAPPED_KEY_UP: /* modifier keys are unmapped */
-		{
-			int32 key;
-			int32 modifiers;
-			if (msg->FindInt32("key", &key) == B_OK && msg->FindInt32("modifiers", &modifiers) == B_OK) {
-				SDL_keysym keysym;
-				keysym.scancode = key;
-				if (key < 128) {
-					keysym.sym = keymap[key];
-				} else {
-					keysym.sym = SDLK_UNKNOWN;
-				}
-				keysym.mod = KMOD_NONE; /* FIX THIS? */
-				keysym.unicode = 0;
-				if (SDL_TranslateUNICODE) {
-					const char *bytes;
-					if (msg->FindString("bytes", &bytes) == B_OK) {
-						keysym.unicode = Translate2Unicode(bytes);
-					}
-				}
-				SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
-			}
-			break;
-		}
-
-		default:
-			/* move it after switch{} so it's always handled
-				that way we keep BeOS feautures like:
-				- CTRL+Q to close window (and other shortcuts)
-				- PrintScreen to make screenshot into /boot/home
-				- etc.. */
-			//BDirectWindow::DispatchMessage(msg, target);
-			break;
-	}
-	BDirectWindow::DispatchMessage(msg, target);
-}
-
-void SDL_BWin::DirectConnected(direct_buffer_info *info) {
-	switch (info->buffer_state & B_DIRECT_MODE_MASK) {
-		case B_DIRECT_START:
-		case B_DIRECT_MODIFY:
-			{
-				int32 width = info->window_bounds.right -
-					info->window_bounds.left;
-				int32 height = info->window_bounds.bottom -
-					info->window_bounds.top;
-				SDL_PrivateResize(width, height);
-				break;
-			}
-		default:
-			break;
-	}
-#if SDL_VIDEO_OPENGL
-	// If it is a BGLView, it is apparently required to
-	// call DirectConnected() on it as well
-	if (this->the_view == this->SDL_GLView)
-		this->SDL_GLView->DirectConnected(info);
-#endif	
-}
diff --git a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysmouse.cc b/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysmouse.cc
deleted file mode 100644
index 9a557d6..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysmouse.cc
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include <AppKit.h>
-#include <GameKit.h>
-
-#include "SDL_BWin.h"
-
-extern "C" {
-#include "../SDL_cursor_c.h"
-#include "SDL_sysmouse_c.h"
-
-/* Convert bits to padded bytes */
-#define PADDED_BITS(bits)  ((bits+7)/8)
-
-/* The implementation dependent data for the window manager cursor */
-struct WMcursor {
-	char *bits;
-};
-
-/* Can this be done in the BeOS? */
-WMcursor *BE_CreateWMCursor(_THIS,
-		Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y)
-{
-	WMcursor *cursor;
-	int allowed_x;
-	int allowed_y;
-	int run, pad, i;
-	char *cptr;
-
-	allowed_x = 16;	/* BeOS limitation */
-	allowed_y = 16;	/* BeOS limitation */
-	if ( (w > allowed_x) || (h > allowed_y) ) {
-		SDL_SetError("Only cursors of dimension (%dx%d) are allowed",
-							allowed_x, allowed_y);
-		return(NULL);
-	}
-
-	/* Allocate the cursor */
-	cursor = (WMcursor *)SDL_malloc(sizeof(WMcursor));
-	if ( cursor == NULL ) {
-		SDL_OutOfMemory();
-		return(NULL);
-	}
-	cursor->bits = (char *)SDL_malloc(4+2*((allowed_x/8)*allowed_y));
-	if ( cursor->bits == NULL ) {
-		SDL_free(cursor);
-		SDL_OutOfMemory();
-		return(NULL);
-	}
-	cursor->bits[0] = allowed_y;		/* Size of the cursor */
-	cursor->bits[1] = 1;			/* Bit depth of cursor */
-	cursor->bits[2] = hot_y;
-	cursor->bits[3] = hot_x;
-	cptr = &cursor->bits[4];
-
-	/* Pad out to the normal cursor size */
-	run = PADDED_BITS(w);
-	pad = PADDED_BITS(allowed_x)-run;
-	for ( i=0; i<h; ++i ) {
-		SDL_memcpy(cptr, data, run);
-		SDL_memset(cptr+run, 0, pad);
-		data += run;
-		cptr += (run+pad);
-	}
-	for ( ; i<allowed_y; ++i ) {
-		SDL_memset(cptr, 0, run+pad);
-		cptr += (run+pad);
-	}
-	for ( i=0; i<h; ++i ) {
-		/* FIXME: The mask should be OR'd with the data to turn 
-		   inverted color pixels black, since inverted color pixels
-		   aren't supported under BeOS.
-		 */
-		SDL_memcpy(cptr, mask, run);
-		SDL_memset(cptr+run, 0, pad);
-		mask += run;
-		cptr += (run+pad);
-	}
-	for ( ; i<allowed_y; ++i ) {
-		SDL_memset(cptr, 0, run+pad);
-		cptr += (run+pad);
-	}
-	return(cursor);
-}
-
-int BE_ShowWMCursor(_THIS, WMcursor *cursor)
-{
-	if ( be_app->Lock() ) {
-		if ( cursor == NULL ) {
-			if ( SDL_BlankCursor != NULL ) {
-				be_app->SetCursor(SDL_BlankCursor->bits);
-			}
-		} else {
-			be_app->SetCursor(cursor->bits);
-		}
-		be_app->Unlock();
-	}
-	return(1);
-}
-
-void BE_FreeWMCursor(_THIS, WMcursor *cursor)
-{
-	SDL_free(cursor->bits);
-	SDL_free(cursor);
-}
-
-/* Implementation by Christian Bauer <cbauer@student.physik.uni-mainz.de> */
-void BE_WarpWMCursor(_THIS, Uint16 x, Uint16 y)
-{
-	BPoint pt;
-	SDL_Win->GetXYOffset(pt.x, pt.y);
-	pt.x += x;
-	pt.y += y;
-	SDL_Win->Lock();
-	SDL_Win->ConvertToScreen(&pt);
-	SDL_Win->Unlock();
-	set_mouse_position((int32)pt.x, (int32)pt.y);
-}
-
-/* Check to see if we need to enter or leave mouse relative mode */
-void BE_CheckMouseMode(_THIS)
-{
-        /* If the mouse is hidden and input is grabbed, we use relative mode */
-        if ( !(SDL_cursorstate & CURSOR_VISIBLE) &&
-             (_this->input_grab != SDL_GRAB_OFF) ) {
-                mouse_relative = 1;
-        } else {
-                mouse_relative = 0;
-        }
-}
-
-}; /* Extern C */
diff --git a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysvideo.cc b/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysvideo.cc
deleted file mode 100644
index c32b661..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysvideo.cc
+++ /dev/null
@@ -1,841 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-/* BWindow based framebuffer implementation */
-
-#include <unistd.h>
-
-#include "SDL_BWin.h"
-#include "SDL_timer.h"
-
-extern "C" {
-
-#include "../SDL_sysvideo.h"
-#include "../../events/SDL_events_c.h"
-#include "SDL_sysevents_c.h"
-#include "SDL_sysmouse_c.h"
-#include "SDL_syswm_c.h"
-#include "SDL_lowvideo.h"
-#include "../SDL_yuvfuncs.h"
-#include "SDL_sysyuv.h"
-#include "../blank_cursor.h"
-
-#define BEOS_HIDDEN_SIZE	32	/* starting hidden window size */
-
-/* Initialization/Query functions */
-static int BE_VideoInit(_THIS, SDL_PixelFormat *vformat);
-static SDL_Rect **BE_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
-static SDL_Surface *BE_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
-static void BE_UpdateMouse(_THIS);
-static int BE_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors);
-static void BE_VideoQuit(_THIS);
-
-/* Hardware surface functions */
-static int BE_AllocHWSurface(_THIS, SDL_Surface *surface);
-static int BE_LockHWSurface(_THIS, SDL_Surface *surface);
-static void BE_UnlockHWSurface(_THIS, SDL_Surface *surface);
-static void BE_FreeHWSurface(_THIS, SDL_Surface *surface);
-
-static int BE_ToggleFullScreen(_THIS, int fullscreen);
-
-/* OpenGL functions */
-#if SDL_VIDEO_OPENGL
-static int BE_GL_LoadLibrary(_THIS, const char *path);
-static void* BE_GL_GetProcAddress(_THIS, const char *proc);
-static int BE_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value);
-static int BE_GL_MakeCurrent(_THIS);
-static void BE_GL_SwapBuffers(_THIS);
-#endif
-
-/* FB driver bootstrap functions */
-
-static int BE_Available(void)
-{
-	return(1);
-}
-
-static void BE_DeleteDevice(SDL_VideoDevice *device)
-{
-	SDL_free(device->hidden);
-	SDL_free(device);
-}
-
-static SDL_VideoDevice *BE_CreateDevice(int devindex)
-{
-	SDL_VideoDevice *device;
-
-	/* Initialize all variables that we clean on shutdown */
-	device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
-	if ( device ) {
-		SDL_memset(device, 0, (sizeof *device));
-		device->hidden = (struct SDL_PrivateVideoData *)
-				SDL_malloc((sizeof *device->hidden));
-	}
-	if ( (device == NULL) || (device->hidden == NULL) ) {
-		SDL_OutOfMemory();
-		if ( device ) {
-			SDL_free(device);
-		}
-		return(0);
-	}
-	SDL_memset(device->hidden, 0, (sizeof *device->hidden));
-
-	/* Set the function pointers */
-	/* Initialization/Query functions */
-	device->VideoInit = BE_VideoInit;
-	device->ListModes = BE_ListModes;
-	device->SetVideoMode = BE_SetVideoMode;
-	device->ToggleFullScreen = BE_ToggleFullScreen;
-	device->UpdateMouse = BE_UpdateMouse;
-	device->CreateYUVOverlay = BE_CreateYUVOverlay;
-	device->SetColors = BE_SetColors;
-	device->UpdateRects = NULL;
-	device->VideoQuit = BE_VideoQuit;
-	/* Hardware acceleration functions */
-	device->AllocHWSurface = BE_AllocHWSurface;
-	device->CheckHWBlit = NULL;
-	device->FillHWRect = NULL;
-	device->SetHWColorKey = NULL;
-	device->SetHWAlpha = NULL;
-	device->LockHWSurface = BE_LockHWSurface;
-	device->UnlockHWSurface = BE_UnlockHWSurface;
-	device->FlipHWSurface = NULL;
-	device->FreeHWSurface = BE_FreeHWSurface;
-	/* Gamma support */
-#if SDL_VIDEO_OPENGL
-	/* OpenGL support */
-	device->GL_LoadLibrary = BE_GL_LoadLibrary;
-	device->GL_GetProcAddress = BE_GL_GetProcAddress;
-	device->GL_GetAttribute = BE_GL_GetAttribute;
-	device->GL_MakeCurrent = BE_GL_MakeCurrent;
-	device->GL_SwapBuffers = BE_GL_SwapBuffers;
-#endif
-	/* Window manager functions */
-	device->SetCaption = BE_SetWMCaption;
-	device->SetIcon = NULL;
-	device->IconifyWindow = BE_IconifyWindow;
-	device->GrabInput = BE_GrabInput;
-	device->GetWMInfo = BE_GetWMInfo;
-	/* Cursor manager functions */
-	device->FreeWMCursor = BE_FreeWMCursor;
-	device->CreateWMCursor = BE_CreateWMCursor;
-	device->ShowWMCursor = BE_ShowWMCursor;
-	device->WarpWMCursor = BE_WarpWMCursor;
-	device->MoveWMCursor = NULL;
-	device->CheckMouseMode = BE_CheckMouseMode;
-	/* Event manager functions */
-	device->InitOSKeymap = BE_InitOSKeymap;
-	device->PumpEvents = BE_PumpEvents;
-
-	device->free = BE_DeleteDevice;
-
-	/* Set the driver flags */
-	device->handles_any_size = 1;
-	
-	return device;
-}
-
-VideoBootStrap BWINDOW_bootstrap = {
-	"bwindow", "BDirectWindow graphics",
-	BE_Available, BE_CreateDevice
-};
-
-static inline int ColorSpaceToBitsPerPixel(uint32 colorspace)
-{
-	int bitsperpixel;
-
-	bitsperpixel = 0;
-	switch (colorspace) {
-	    case B_CMAP8:
-		bitsperpixel = 8;
-		break;
-	    case B_RGB15:
-	    case B_RGBA15:
-	    case B_RGB15_BIG:
-	    case B_RGBA15_BIG:
-		bitsperpixel = 15;
-		break;
-	    case B_RGB16:
-	    case B_RGB16_BIG:
-		bitsperpixel = 16;
-		break;
-	    case B_RGB32:
-	    case B_RGBA32:
-	    case B_RGB32_BIG:
-	    case B_RGBA32_BIG:
-		bitsperpixel = 32;
-		break;
-	    default:
-		break;
-	}
-	return(bitsperpixel);
-}
-
-/* Function to sort the display_list in bscreen */
-static int CompareModes(const void *A, const void *B)
-{
-	const display_mode *a = (display_mode *)A;
-	const display_mode *b = (display_mode *)B;
-
-	if ( a->space == b->space ) {
-		return((b->virtual_width*b->virtual_height)-
-		       (a->virtual_width*a->virtual_height));
-	} else {
-		return(ColorSpaceToBitsPerPixel(b->space)-
-		       ColorSpaceToBitsPerPixel(a->space));
-	}
-}
-
-/* Yes, this isn't the fastest it could be, but it works nicely */
-static int BE_AddMode(_THIS, int index, unsigned int w, unsigned int h)
-{
-	SDL_Rect *mode;
-	int i;
-	int next_mode;
-
-	/* Check to see if we already have this mode */
-	if ( SDL_nummodes[index] > 0 ) {
-		for ( i=SDL_nummodes[index]-1; i >= 0; --i ) {
-			mode = SDL_modelist[index][i];
-			if ( (mode->w == w) && (mode->h == h) ) {
-#ifdef BWINDOW_DEBUG
-				fprintf(stderr, "We already have mode %dx%d at %d bytes per pixel\n", w, h, index+1);
-#endif
-				return(0);
-			}
-		}
-	}
-
-	/* Set up the new video mode rectangle */
-	mode = (SDL_Rect *)SDL_malloc(sizeof *mode);
-	if ( mode == NULL ) {
-		SDL_OutOfMemory();
-		return(-1);
-	}
-	mode->x = 0;
-	mode->y = 0;
-	mode->w = w;
-	mode->h = h;
-#ifdef BWINDOW_DEBUG
-	fprintf(stderr, "Adding mode %dx%d at %d bytes per pixel\n", w, h, index+1);
-#endif
-
-	/* Allocate the new list of modes, and fill in the new mode */
-	next_mode = SDL_nummodes[index];
-	SDL_modelist[index] = (SDL_Rect **)
-	       SDL_realloc(SDL_modelist[index], (1+next_mode+1)*sizeof(SDL_Rect *));
-	if ( SDL_modelist[index] == NULL ) {
-		SDL_OutOfMemory();
-		SDL_nummodes[index] = 0;
-		SDL_free(mode);
-		return(-1);
-	}
-	SDL_modelist[index][next_mode] = mode;
-	SDL_modelist[index][next_mode+1] = NULL;
-	SDL_nummodes[index]++;
-
-	return(0);
-}
-
-int BE_VideoInit(_THIS, SDL_PixelFormat *vformat)
-{
-	display_mode *modes;
-	uint32 i, nmodes;
-	int bpp;
-	BRect bounds;
-
-	/* Initialize the Be Application for appserver interaction */
-	if ( SDL_InitBeApp() < 0 ) {
-		return(-1);
-	}
-
-	/* It is important that this be created after SDL_InitBeApp() */
-	BScreen bscreen;
-
-	/* Save the current display mode */
-	bscreen.GetMode(&saved_mode);
-	_this->info.current_w = saved_mode.virtual_width;
-	_this->info.current_h = saved_mode.virtual_height;
-
-	/* Determine the screen depth */
-	vformat->BitsPerPixel = ColorSpaceToBitsPerPixel(bscreen.ColorSpace());
-	if ( vformat->BitsPerPixel == 0 ) {
-		SDL_SetError("Unknown BScreen colorspace: 0x%x",
-						bscreen.ColorSpace());
-		return(-1);
-	}
-
-	/* Get the video modes we can switch to in fullscreen mode */
-	bscreen.GetModeList(&modes, &nmodes);
-	SDL_qsort(modes, nmodes, sizeof *modes, CompareModes);
-	for ( i=0; i<nmodes; ++i ) {
-		bpp = ColorSpaceToBitsPerPixel(modes[i].space);
-		//if ( bpp != 0 ) { // There are bugs in changing colorspace
-		if ( modes[i].space == saved_mode.space ) {
-			BE_AddMode(_this, ((bpp+7)/8)-1,
-				modes[i].virtual_width,
-				modes[i].virtual_height);
-		}
-	}
-
-	/* Create the window and view */
-	bounds.top = 0; bounds.left = 0;
-	bounds.right = BEOS_HIDDEN_SIZE;
-	bounds.bottom = BEOS_HIDDEN_SIZE;
-	SDL_Win = new SDL_BWin(bounds);
-
-#if SDL_VIDEO_OPENGL
-	/* testgl application doesn't load library, just tries to load symbols */
-	/* is it correct? if so we have to load library here */
-	BE_GL_LoadLibrary(_this, NULL);
-#endif
-
-	/* Create the clear cursor */
-	SDL_BlankCursor = BE_CreateWMCursor(_this, blank_cdata, blank_cmask,
-			BLANK_CWIDTH, BLANK_CHEIGHT, BLANK_CHOTX, BLANK_CHOTY);
-
-	/* Fill in some window manager capabilities */
-	_this->info.wm_available = 1;
-
-	/* We're done! */
-	return(0);
-}
-
-/* We support any dimension at our bit-depth */
-SDL_Rect **BE_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
-{
-	SDL_Rect **modes;
-
-	modes = ((SDL_Rect **)0);
-	if ( (flags & SDL_FULLSCREEN) == SDL_FULLSCREEN ) {
-		modes = SDL_modelist[((format->BitsPerPixel+7)/8)-1];
-	} else {
-		if ( format->BitsPerPixel ==
-			_this->screen->format->BitsPerPixel ) {
-			modes = ((SDL_Rect **)-1);
-		}
-	}
-	return(modes);
-}
-
-/* Various screen update functions available */
-static void BE_NormalUpdate(_THIS, int numrects, SDL_Rect *rects);
-
-
-/* Find the closest display mode for fullscreen */
-static bool BE_FindClosestFSMode(_THIS, int width, int height, int bpp,
-					 display_mode *mode)
-{
-	BScreen bscreen;
-	uint32 i, nmodes;
-	SDL_Rect **modes;
-	display_mode *dmodes;
-	display_mode current;
-	float current_refresh;
-	bscreen.GetMode(&current);
-	current_refresh = (1000 * current.timing.pixel_clock) / 
-	                  (current.timing.h_total * current.timing.v_total);
-
-	modes = SDL_modelist[((bpp+7)/8)-1];
-	
-	// find end of list (lowest-resolution mode; modes are ordered
-	// highest-to-lowest).
-	i = 0; while(modes[i]) i++;
-	if (!i) return false;		// what? no modes at all?
-	
-	// find first mode with resolution >= requested in both dimensions
-	for (--i; i >= 0; --i)
-	{
-		if (modes[i]->w >= width && modes[i]->h >= height)
-			break;
-	}
-	
-	// unable to find any mode with that high a resolution!
-	if (i < 0)
-		return false;
-	
-	width = modes[i]->w;
-	height = modes[i]->h;
-
-	bscreen.GetModeList(&dmodes, &nmodes);
-	for ( i = 0; i < nmodes; ++i ) {
-		if ( (bpp == ColorSpaceToBitsPerPixel(dmodes[i].space)) &&
-		     (width == dmodes[i].virtual_width) &&
-		     (height == dmodes[i].virtual_height) ) {
-			break;
-		}
-	}
-	if ( i != nmodes ) {
-		*mode = dmodes[i];
-		if ((mode->virtual_width <= current.virtual_width) &&
-		    (mode->virtual_height <= current.virtual_height)) {
-			float new_refresh = (1000 * mode->timing.pixel_clock) /
-			                    (mode->timing.h_total * mode->timing.v_total);
-			if (new_refresh < current_refresh) {
-				mode->timing.pixel_clock = (uint32)((mode->timing.h_total * mode->timing.v_total)
-				                                    * current_refresh / 1000);
-			}
-		}
-		return true;
-	} else {
-		return false;
-	}	
-}
-
-static int BE_SetFullScreen(_THIS, SDL_Surface *screen, int fullscreen)
-{
-	// printf("SetFullScreen(%d)\n", fullscreen);
-	BScreen bscreen;
-
-	// SetFullSscreen() does not work as expected if called in a window
-	// that was never shown. This is probably a bug in the Haiku Game Kit that needs
-	// to be investigated.	
-	if (SDL_Win->Lock()) {
-		// Show our window.
-		SDL_Win->Show();
-	}	
-	
-	if (SDL_Win->IsLocked()) {
-		// Unlock the window if it was locked. This is needed as only the
-		// first call to Show() unlocks the looper. All other calls to it
-		// will not.
-		SDL_Win->Unlock();
-	}
-
-	int width = screen->w;
-	int height = screen->h;
-	
-	if (fullscreen) {
-		// Set resolution to the closest available one that matches the
-		// current SDL resolution.
-		display_mode mode;
-		bscreen.GetMode(&mode);
-
-		int bpp = screen->format->BitsPerPixel;
-		if (bpp != ColorSpaceToBitsPerPixel(mode.space) ||
-			width != mode.virtual_width || height != mode.virtual_height) {
-			if(BE_FindClosestFSMode(_this, width, height, bpp, &mode)) {
-				bscreen.SetMode(&mode);
-			} else {
-				// printf("Could not set new mode.\n");
-				return(0);
-			}			
-		}
-	} else {
-		// Reset to the previous known resolution as we are now in window
-		// mode.
-		bscreen.SetMode(&saved_mode);	
-	}
-	
-	// Effectivelly set/reset full screen mode. If we are already in
-	// full screen mode, we reset back to windowed mode first so the
-	// window can resize when going fullscreen.
-	// if (fullscreen)
-		// printf("Going fullscreen\n");
-	// else
-		// printf("Going windowed\n"); 
-	SDL_Win->SetFullScreen(fullscreen);
-	
-	// Calculate offsets for centering the window (in window mode) and for
-	// dentering the bitmap (in full screen mode).
-	BRect bounds = bscreen.Frame();
-	bounds.PrintToStream();
-	int32 cx = (bounds.IntegerWidth() - width)/2;
-	int32 cy = (bounds.IntegerHeight() - height)/2;
-	
-	// printf ("cx = %d, cy = %d\n", cx, cy);
-	if (!SDL_Win->IsFullScreen()) {
-		// printf("Doing not fullscreen stuff.\n");
-		// We are not in full screen mode, so we want to change the window
-		// size to match the resolution in SDL.
-		SDL_Win->ResizeTo(width, height);
-		
-		// And also center the window and reset the drawing offset.
-		SDL_Win->MoveTo(cx, cy);
-		SDL_Win->SetXYOffset(0, 0);
-	} else {
-		// printf("Doing fullscreen stuff.");
-		// Center the bitmap whenever we are in full screen mode.
-		SDL_Win->SetXYOffset(cx, cy);
-	}
-	
-	// Set relevant internal SDL screen flags.
-	if (SDL_Win->IsFullScreen()) {
-		screen->flags |= SDL_FULLSCREEN;
-	} else {
-		screen->flags &= ~SDL_FULLSCREEN; 
-	}
-
-	return(1);
-}
-
-static int BE_ToggleFullScreen(_THIS, int fullscreen)
-{
-	return BE_SetFullScreen(_this, _this->screen, fullscreen);
-}
-
-/* FIXME: check return values and cleanup here */
-SDL_Surface *BE_SetVideoMode(_THIS, SDL_Surface *current,
-				int width, int height, int bpp, Uint32 flags)
-{
-	BScreen bscreen;
-	BBitmap *bbitmap;
-	BRect bounds;
-	Uint32 gl_flags = 0;
-
-	/* Only RGB works on r5 currently */
-	gl_flags = BGL_RGB;
-	if (_this->gl_config.double_buffer)
-		gl_flags |= BGL_DOUBLE;
-	else
-		gl_flags |= BGL_SINGLE;
-	if (_this->gl_config.alpha_size > 0 || bpp == 32)
-		gl_flags |= BGL_ALPHA;
-	if (_this->gl_config.depth_size > 0)
-		gl_flags |= BGL_DEPTH;
-	if (_this->gl_config.stencil_size > 0)
-		gl_flags |= BGL_STENCIL;
-	if (_this->gl_config.accum_red_size > 0
-		|| _this->gl_config.accum_green_size > 0
-		|| _this->gl_config.accum_blue_size > 0
-		|| _this->gl_config.accum_alpha_size > 0)
-		gl_flags |= BGL_ACCUM;
-
-	/* Create the view for this window, using found flags */
-	if ( SDL_Win->CreateView(flags, gl_flags) < 0 ) {
-		return(NULL);
-	}
-
-	current->flags = 0;		/* Clear flags */
-	current->w = width;
-	current->h = height;
-	SDL_Win->SetType(B_TITLED_WINDOW);
-	if ( flags & SDL_NOFRAME ) {
-		current->flags |= SDL_NOFRAME;
-		SDL_Win->SetLook(B_NO_BORDER_WINDOW_LOOK);
-	} else {
-		if ( (flags & SDL_RESIZABLE) && !(flags & SDL_OPENGL) )  {
-			current->flags |= SDL_RESIZABLE;
-			/* We don't want opaque resizing (TM). :-) */
-			SDL_Win->SetFlags(B_OUTLINE_RESIZE);
-		} else {
-			SDL_Win->SetFlags(B_NOT_RESIZABLE|B_NOT_ZOOMABLE);
-		}
-	}
-
-	if ( flags & SDL_OPENGL ) {
-		current->flags |= SDL_OPENGL;
-		current->pitch = 0;
-		current->pixels = NULL;
-		_this->UpdateRects = NULL;
-	} else {
-		/* Create the BBitmap framebuffer */
-		bounds.top = 0; bounds.left = 0;
-		bounds.right = width-1;
-		bounds.bottom = height-1;
-		bbitmap = new BBitmap(bounds, bscreen.ColorSpace());
-		if ( ! bbitmap->IsValid() ) {
-			SDL_SetError("Couldn't create screen bitmap");
-			delete bbitmap;
-			return(NULL);
-		}
-		current->pitch = bbitmap->BytesPerRow();
-		current->pixels = (void *)bbitmap->Bits();
-		SDL_Win->SetBitmap(bbitmap);
-		_this->UpdateRects = BE_NormalUpdate;
-	}
-
-	/* Set the correct fullscreen mode */
-	BE_SetFullScreen(_this, current, flags & SDL_FULLSCREEN ? 1 : 0);
-
-	/* We're done */
-	return(current);
-}
-
-/* Update the current mouse state and position */
-void BE_UpdateMouse(_THIS)
-{
-	BPoint point;
-	uint32 buttons;
-
-	if ( SDL_Win->Lock() ) {
-		/* Get new input state, if still active */
-		if ( SDL_Win->IsActive() ) {
-			(SDL_Win->View())->GetMouse(&point, &buttons, true);
-		} else {
-			point.x = -1;
-			point.y = -1;
-		}
-		SDL_Win->Unlock();
-
-		if ( (point.x >= 0) && (point.x < SDL_VideoSurface->w) &&
-		     (point.y >= 0) && (point.y < SDL_VideoSurface->h) ) {
-			SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
-			SDL_PrivateMouseMotion(0, 0,
-					(Sint16)point.x, (Sint16)point.y);
-		} else {
-			SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
-		}
-	}
-}
-
-/* We don't actually allow hardware surfaces other than the main one */
-static int BE_AllocHWSurface(_THIS, SDL_Surface *surface)
-{
-	return(-1);
-}
-static void BE_FreeHWSurface(_THIS, SDL_Surface *surface)
-{
-	return;
-}
-static int BE_LockHWSurface(_THIS, SDL_Surface *surface)
-{
-	return(0);
-}
-static void BE_UnlockHWSurface(_THIS, SDL_Surface *surface)
-{
-	return;
-}
-
-static void BE_NormalUpdate(_THIS, int numrects, SDL_Rect *rects)
-{
-	if ( SDL_Win->BeginDraw() ) {
-		int i;
-
-		for ( i=0; i<numrects; ++i ) {
-			BRect rect;
-
-			rect.top = rects[i].y;
-			rect.left = rects[i].x;
-			rect.bottom = rect.top+rects[i].h-1;
-			rect.right = rect.left+rects[i].w-1;
-			SDL_Win->DrawAsync(rect);
-		}
-		SDL_Win->EndDraw();
-	}
-}
-
-#if SDL_VIDEO_OPENGL
-/* Passing a NULL path means load pointers from the application */
-int BE_GL_LoadLibrary(_THIS, const char *path)
-{
-	if (path == NULL) {
-		if (_this->gl_config.dll_handle == NULL) {
-			image_info info;
-			int32 cookie = 0;
-			while (get_next_image_info(0,&cookie,&info) == B_OK) {
-				void *location = NULL;
-#ifdef __HAIKU__
-				if (get_image_symbol(info.id,"glBegin",B_SYMBOL_TYPE_ANY,&location) == B_OK) { // This is how it actually works in Haiku
-#else
-				if (get_image_symbol((image_id)cookie,"glBegin",B_SYMBOL_TYPE_ANY,&location) == B_OK) { // I don't know if that *did* work in BeOS
-#endif
-					_this->gl_config.dll_handle = (void*)info.id;
-					_this->gl_config.driver_loaded = 1;
-					SDL_strlcpy(_this->gl_config.driver_path, "libGL.so", SDL_arraysize(_this->gl_config.driver_path));
-				}
-			}
-		}
-	} else {
-		/*
-			FIXME None of BeOS libGL.so implementations have exported functions 
-			to load BGLView, which should be reloaded from new lib.
-			So for now just "load" linked libGL.so :(
-		*/
-		if (_this->gl_config.dll_handle == NULL) {
-			return BE_GL_LoadLibrary(_this, NULL);
-		}
-
-		/* Unload old first */
-		/*if (_this->gl_config.dll_handle != NULL) {*/
-			/* Do not try to unload application itself (if LoadLibrary was called before with NULL ;) */
-		/*	image_info info;
-			if (get_image_info((image_id)_this->gl_config.dll_handle, &info) == B_OK) {
-				if (info.type != B_APP_IMAGE) {
-					unload_add_on((image_id)_this->gl_config.dll_handle);
-				}
-			}
-			
-		}
-
-		if ((_this->gl_config.dll_handle = (void*)load_add_on(path)) != (void*)B_ERROR) {
-			_this->gl_config.driver_loaded = 1;
-			SDL_strlcpy(_this->gl_config.driver_path, path, SDL_arraysize(_this->gl_config.driver_path));
-		}*/
-	}
-
-	if (_this->gl_config.dll_handle != NULL) {
-		return 0;
-	} else {
-		_this->gl_config.dll_handle = NULL;
-		_this->gl_config.driver_loaded = 0;
-		*_this->gl_config.driver_path = '\0';
-		return -1;
-	}
-}
-
-void* BE_GL_GetProcAddress(_THIS, const char *proc)
-{
-	if (_this->gl_config.dll_handle != NULL) {
-		void *location = NULL;
-		status_t err;
-		if ((err = get_image_symbol((image_id)_this->gl_config.dll_handle, proc, B_SYMBOL_TYPE_ANY, &location)) == B_OK) {
-			return location;
-		} else {
-			SDL_SetError("Couldn't find OpenGL symbol");
-			return NULL;
-		}
-	} else {
-		SDL_SetError("OpenGL library not loaded");
-		return NULL;
-	}
-}
-
-int BE_GL_GetAttribute(_THIS, SDL_GLattr attrib, int* value)
-{
-	/*
-		FIXME? Right now BE_GL_GetAttribute shouldn't be called between glBegin() and glEnd() - it doesn't use "cached" values
-	*/
-	switch (attrib)
-    {
-		case SDL_GL_RED_SIZE:
-			glGetIntegerv(GL_RED_BITS, (GLint*)value);
-			break;
-		case SDL_GL_GREEN_SIZE:
-			glGetIntegerv(GL_GREEN_BITS, (GLint*)value);
-			break;
-		case SDL_GL_BLUE_SIZE:
-			glGetIntegerv(GL_BLUE_BITS, (GLint*)value);
-			break;
-		case SDL_GL_ALPHA_SIZE:
-			glGetIntegerv(GL_ALPHA_BITS, (GLint*)value);
-			break;
-		case SDL_GL_DOUBLEBUFFER:
-			glGetBooleanv(GL_DOUBLEBUFFER, (GLboolean*)value);
-			break;
-		case SDL_GL_BUFFER_SIZE:
-			int v;
-			glGetIntegerv(GL_RED_BITS, (GLint*)&v);
-			*value = v;
-			glGetIntegerv(GL_GREEN_BITS, (GLint*)&v);
-			*value += v;
-			glGetIntegerv(GL_BLUE_BITS, (GLint*)&v);
-			*value += v;
-			glGetIntegerv(GL_ALPHA_BITS, (GLint*)&v);
-			*value += v;
-			break;
-		case SDL_GL_DEPTH_SIZE:
-			glGetIntegerv(GL_DEPTH_BITS, (GLint*)value); /* Mesa creates 16 only? r5 always 32 */
-			break;
-		case SDL_GL_STENCIL_SIZE:
-			glGetIntegerv(GL_STENCIL_BITS, (GLint*)value);
-			break;
-		case SDL_GL_ACCUM_RED_SIZE:
-			glGetIntegerv(GL_ACCUM_RED_BITS, (GLint*)value);
-			break;
-		case SDL_GL_ACCUM_GREEN_SIZE:
-			glGetIntegerv(GL_ACCUM_GREEN_BITS, (GLint*)value);
-			break;
-		case SDL_GL_ACCUM_BLUE_SIZE:
-			glGetIntegerv(GL_ACCUM_BLUE_BITS, (GLint*)value);
-			break;
-		case SDL_GL_ACCUM_ALPHA_SIZE:
-			glGetIntegerv(GL_ACCUM_ALPHA_BITS, (GLint*)value);
-			break;
-		case SDL_GL_STEREO:
-		case SDL_GL_MULTISAMPLEBUFFERS:
-		case SDL_GL_MULTISAMPLESAMPLES:
-		default:
-			*value=0;
-			return(-1);
-	}
-	return 0;
-}
-
-int BE_GL_MakeCurrent(_THIS)
-{
-	/* FIXME: should we glview->unlock and then glview->lock()? */
-	return 0;
-}
-
-void BE_GL_SwapBuffers(_THIS)
-{
-	SDL_Win->SwapBuffers();
-}
-#endif
-
-/* Is the system palette settable? */
-int BE_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
-{
-	int i;
-	SDL_Palette *palette;
-	const color_map *cmap = BScreen().ColorMap();
-
-	/* Get the screen colormap */
-	palette = _this->screen->format->palette;
-	for ( i=0; i<256; ++i ) {
-		palette->colors[i].r = cmap->color_list[i].red;
-		palette->colors[i].g = cmap->color_list[i].green;
-		palette->colors[i].b = cmap->color_list[i].blue;
-	}
-	return(0);
-}
-
-void BE_VideoQuit(_THIS)
-{
-	int i, j;
-
-	SDL_Win->Quit();
-	SDL_Win = NULL;
-
-	if ( SDL_BlankCursor != NULL ) {
-		BE_FreeWMCursor(_this, SDL_BlankCursor);
-		SDL_BlankCursor = NULL;
-	}
-	for ( i=0; i<NUM_MODELISTS; ++i ) {
-		if ( SDL_modelist[i] ) {
-			for ( j=0; SDL_modelist[i][j]; ++j ) {
-				SDL_free(SDL_modelist[i][j]);
-			}
-			SDL_free(SDL_modelist[i]);
-			SDL_modelist[i] = NULL;
-		}
-	}
-	/* Restore the original video mode */
-	if ( _this->screen ) {
-		if ( (_this->screen->flags&SDL_FULLSCREEN) == SDL_FULLSCREEN ) {
-			BScreen bscreen;
-			bscreen.SetMode(&saved_mode);
-		}
-		_this->screen->pixels = NULL;
-	}
-
-#if SDL_VIDEO_OPENGL
-	if (_this->gl_config.dll_handle != NULL)
-		unload_add_on((image_id)_this->gl_config.dll_handle);
-#endif
-
-	SDL_QuitBeApp();
-}
-
-}; /* Extern C */
diff --git a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_syswm.cc b/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_syswm.cc
deleted file mode 100644
index df80100..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_syswm.cc
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include "SDL_BWin.h"
-
-extern "C" {
-#include "SDL_syswm_c.h"
-#include "SDL_error.h"
-#include "../SDL_cursor_c.h"
-
-void BE_SetWMCaption(_THIS, const char *title, const char *icon)
-{
-	SDL_Win->SetTitle(title);
-}
-
-int BE_IconifyWindow(_THIS)
-{
-	SDL_Win->Minimize(true);
-	return 1;
-}
-
-SDL_GrabMode BE_GrabInput(_THIS, SDL_GrabMode mode)
-{
-	if ( mode == SDL_GRAB_OFF ) {
-//		be_app->ShowCursor();
-		if ( !(SDL_cursorstate & CURSOR_VISIBLE) ) {
-		/*	BeSman: Jan 2, 2006
-			must be leaving relative mode, move mouse from
-			center of window to where it belongs ... */
-			BPoint pt;
-			int x, y;
-			SDL_GetMouseState(&x,&y);
-			pt.x = x;
-			pt.y = y;
-			SDL_Win->Lock();
-			SDL_Win->ConvertToScreen(&pt);
-			SDL_Win->Unlock();
-			set_mouse_position((int)pt.x, (int)pt.y);
-		}
-	} else {
-//		be_app->HideCursor();
-		if ( !(SDL_cursorstate & CURSOR_VISIBLE) ) {
-		/*	BeSman: Jan 2, 2006
-			must be entering relative mode, get ready by
-			moving mouse to	center of window ... */
-			BPoint pt;
-			pt.x = (SDL_VideoSurface->w/2);
-			pt.y = (SDL_VideoSurface->h/2);
-			SDL_Win->Lock();
-			SDL_Win->ConvertToScreen(&pt);
-			SDL_Win->Unlock();
-			set_mouse_position((int)pt.x, (int)pt.y);
-		}
-	}
-	return(mode);
-}
-
-int BE_GetWMInfo(_THIS, SDL_SysWMinfo *info)
-{
-    if (info->version.major <= SDL_MAJOR_VERSION)
-    {
-        return 1;
-    }
-    else
-    {
-        SDL_SetError("Application not compiled with SDL %d.%d\n",
-                      SDL_MAJOR_VERSION, SDL_MINOR_VERSION);
-        return -1;
-    }
-}
-
-}; /* Extern C */
diff --git a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysyuv.cc b/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysyuv.cc
deleted file mode 100644
index 7c71b00..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/bwindow/SDL_sysyuv.cc
+++ /dev/null
@@ -1,314 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-/* This is the BeOS version of SDL YUV video overlays */
-
-#include "SDL_video.h"
-#include "SDL_sysyuv.h"
-#include "../SDL_yuvfuncs.h"
-
-extern "C" {
-
-/* The functions used to manipulate software video overlays */
-static struct private_yuvhwfuncs be_yuvfuncs =
-{
-    BE_LockYUVOverlay,
-    BE_UnlockYUVOverlay,
-    BE_DisplayYUVOverlay,
-    BE_FreeYUVOverlay
-};
-
-BBitmap * BE_GetOverlayBitmap(BRect bounds, color_space cs) {
-	BBitmap *bbitmap;
-	bbitmap = new BBitmap(bounds,B_BITMAP_WILL_OVERLAY,cs);
-	if (!bbitmap || bbitmap->InitCheck() != B_OK) {
-		delete bbitmap;
-		return 0;
-	}
-	overlay_restrictions r;
-	bbitmap->GetOverlayRestrictions(&r);
-	uint32 width = bounds.IntegerWidth() + 1;
-	uint32 height = bounds.IntegerHeight() + 1;
-	uint32 width_padding = 0;
-	uint32 height_padding = 0;
-	if ((r.source.horizontal_alignment != 0) ||
-	    (r.source.vertical_alignment != 0)) {
-		delete bbitmap;
-		return 0;
-	}
-	if (r.source.width_alignment != 0) {
-		uint32 aligned_width = r.source.width_alignment + 1;
-		if (width % aligned_width > 0) {
-			width_padding = aligned_width - width % aligned_width;
-		}
-	}
-	if (r.source.height_alignment != 0) {
-		uint32 aligned_height = r.source.height_alignment + 1;
-		if (height % aligned_height > 0) {
-			fprintf(stderr,"GetOverlayBitmap failed height alignment\n");
-			fprintf(stderr,"- height = %lu, aligned_height = %lu\n",height,aligned_height);
-			delete bbitmap;
-			return 0;
-		}
-	}
-	if ((r.source.min_width > width) ||
-	    (r.source.min_height > height) ||
-	    (r.source.max_width < width) ||
-	    (r.source.max_height < height)) {
-		fprintf(stderr,"GetOverlayBitmap failed bounds tests\n");
-	    delete bbitmap;
-	    return 0;
-	}
-	if ((width_padding != 0) || (height_padding != 0)) {
-		delete bbitmap;
-		bounds.Set(bounds.left,bounds.top,bounds.right+width_padding,bounds.bottom+height_padding);
-		bbitmap = new BBitmap(bounds,B_BITMAP_WILL_OVERLAY,cs);
-		if (!bbitmap || bbitmap->InitCheck() != B_OK) {
-			fprintf(stderr,"GetOverlayBitmap failed late\n");
-			delete bbitmap;
-			return 0;
-		}
-	}		
-	return bbitmap;	    
-}
-
-// See <GraphicsDefs.h> [btw: Cb=U, Cr=V]
-// See also http://www.fourcc.org/indexyuv.htm
-color_space convert_color_space(Uint32 format) {
-	switch (format) {
-	case SDL_YV12_OVERLAY:
-		return B_YUV9;
-	case SDL_IYUV_OVERLAY:
-		return B_YUV12;
-	case SDL_YUY2_OVERLAY:
-		return B_YCbCr422;
-	case SDL_UYVY_OVERLAY:
-		return B_YUV422;
-	case SDL_YVYU_OVERLAY: // not supported on beos?
-		return B_NO_COLOR_SPACE;
-	default:
-		return B_NO_COLOR_SPACE;
-	}
-}
-
-// See SDL_video.h
-int count_planes(Uint32 format) {
-	switch (format) {
-	case SDL_YV12_OVERLAY:
-	case SDL_IYUV_OVERLAY:
-		return 3;
-	case SDL_YUY2_OVERLAY:
-	case SDL_UYVY_OVERLAY:
-	case SDL_YVYU_OVERLAY:
-		return 1;
-	default:
-		return 0;
-	}
-}		
-
-SDL_Overlay *BE_CreateYUVOverlay(_THIS, int width, int height, Uint32 format, SDL_Surface *display) {
-	SDL_Overlay* overlay;
-	struct private_yuvhwdata* hwdata;
-	BBitmap *bbitmap;
-	int planes;
-	BRect bounds;
-	color_space cs;
-	
-	/* find the appropriate BeOS colorspace descriptor */
-	cs = convert_color_space(format);
-	if (cs == B_NO_COLOR_SPACE)
-	{
-		return NULL;
-	}
-	
-	/* count planes */
-	planes = count_planes(format);
-	if (planes == 0)
-	{
-		return NULL;
-	}
-	/* TODO: figure out planar modes, if anyone cares */
-	if (planes == 3)
-	{
-		return NULL;
-	}
-
-    /* Create the overlay structure */
-    overlay = (SDL_Overlay*)SDL_calloc(1, sizeof(SDL_Overlay));
-
-    if (overlay == NULL)
-    {
-        SDL_OutOfMemory();
-        return NULL;
-    }
-
-    /* Fill in the basic members */
-    overlay->format = format;
-    overlay->w = width;
-    overlay->h = height;
-    overlay->hwdata = NULL;
-	
-    /* Set up the YUV surface function structure */
-    overlay->hwfuncs = &be_yuvfuncs;
-
-    /* Create the pixel data and lookup tables */
-    hwdata = (struct private_yuvhwdata*)SDL_calloc(1, sizeof(struct private_yuvhwdata));
-
-    if (hwdata == NULL)
-    {
-        SDL_OutOfMemory();
-        SDL_FreeYUVOverlay(overlay);
-        return NULL;
-    }
-
-    overlay->hwdata = hwdata;
-	overlay->hwdata->display = display;
-	overlay->hwdata->bview = NULL;
-	overlay->hwdata->bbitmap = NULL;
-	overlay->hwdata->locked = 0;
-
-	/* Create the BBitmap framebuffer */
-	bounds.top = 0;	bounds.left = 0;
-	bounds.right = width-1;
-	bounds.bottom = height-1;
-	
-	BView * bview = new BView(bounds,"overlay",B_FOLLOW_NONE,B_WILL_DRAW); 
-	if (!bview) {
-		SDL_OutOfMemory();
-        SDL_FreeYUVOverlay(overlay);
-        return NULL;
-	}
-	overlay->hwdata->bview = bview;
-	overlay->hwdata->first_display = true;
-	bview->Hide();
-	
-	bbitmap = BE_GetOverlayBitmap(bounds,cs);
-	if (!bbitmap) {
-		overlay->hwdata->bbitmap = NULL;
-		SDL_FreeYUVOverlay(overlay);
-		return NULL;
-	}
-	overlay->hwdata->bbitmap = bbitmap;
-	
-	overlay->planes = planes;
-	overlay->pitches = (Uint16*)SDL_calloc(overlay->planes, sizeof(Uint16));
-	overlay->pixels  = (Uint8**)SDL_calloc(overlay->planes, sizeof(Uint8*));
-	if (!overlay->pitches || !overlay->pixels)
-	{
-        SDL_OutOfMemory();
-        SDL_FreeYUVOverlay(overlay);
-        return(NULL);
-    }
-
-   	overlay->pitches[0] = bbitmap->BytesPerRow();
-   	overlay->pixels[0]  = (Uint8 *)bbitmap->Bits();
-	overlay->hw_overlay = 1;
-	
-	if (SDL_Win->LockWithTimeout(1000000) != B_OK) {
-        SDL_FreeYUVOverlay(overlay);
-        return(NULL);
-    }
-	BView * view = SDL_Win->View();
-    view->AddChild(bview);
-    rgb_color key;
-    bview->SetViewOverlay(bbitmap,bounds,bview->Bounds(),&key,B_FOLLOW_ALL,
-                         B_OVERLAY_FILTER_HORIZONTAL|B_OVERLAY_FILTER_VERTICAL);
-    bview->SetViewColor(key);
-    bview->Flush();
-	SDL_Win->Unlock();
-	
-	current_overlay=overlay;
-        
-	return overlay;
-}
-
-int BE_LockYUVOverlay(_THIS, SDL_Overlay* overlay)
-{
-    if (overlay == NULL)
-    {
-        return 0;
-    }
-
-    overlay->hwdata->locked = 1;
-    return 0;
-}
-
-void BE_UnlockYUVOverlay(_THIS, SDL_Overlay* overlay)
-{
-    if (overlay == NULL)
-    {
-         return;
-    }
-
-    overlay->hwdata->locked = 0;
-}
-
-int BE_DisplayYUVOverlay(_THIS, SDL_Overlay* overlay, SDL_Rect* src, SDL_Rect *dst)
-{
-    if ((overlay == NULL) || (overlay->hwdata==NULL)
-        || (overlay->hwdata->bview==NULL) || (SDL_Win->View() == NULL))
-    {
-        return -1;
-    }
-    if (SDL_Win->LockWithTimeout(50000) != B_OK) {
-        return 0;
-    }
-    BView * bview = overlay->hwdata->bview;
-    if (SDL_Win->IsFullScreen()) {
-    	int left,top;
-    	SDL_Win->GetXYOffset(left,top);
-	    bview->MoveTo(left+dst->x,top+dst->y);
-    } else {
-	    bview->MoveTo(dst->x,dst->y);
-    }
-    bview->ResizeTo(dst->w,dst->h);
-    bview->Flush();
-	if (overlay->hwdata->first_display) {
-		bview->Show();
-		overlay->hwdata->first_display = false;
-	}
-    SDL_Win->Unlock();
-    
-	return 0;
-}
-
-void BE_FreeYUVOverlay(_THIS, SDL_Overlay *overlay)
-{
-    if (overlay == NULL)
-    {
-        return;
-    }
-
-    if (overlay->hwdata == NULL)
-    {
-        return;
-    }
-
-    current_overlay=NULL;
-
-	delete overlay->hwdata->bbitmap;
-
-    SDL_free(overlay->hwdata);
-}
-
-}; // extern "C"
diff --git a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_QPEApp.cc b/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_QPEApp.cc
deleted file mode 100644
index 8daf1c5..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_QPEApp.cc
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public
-    License along with this library; if not, write to the Free
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include <qpe/qpeapplication.h>
-#include <qapplication.h>
-#include <qevent.h>
-
-#include "SDL_thread.h"
-#include "SDL_timer.h"
-#include "SDL_error.h"
-
-/* Flag to tell whether or not the Be application is active or not */
-int SDL_QPEAppActive = 0;
-static QPEApplication *app;
-
-int SDL_InitQPEApp() {
-  if(SDL_QPEAppActive <= 0) {
-    if(!qApp) {
-      int argc = 1;
-      char *argv[] = { { "SDLApp" } };
-      app = new QPEApplication(argc, argv);
-      QWidget dummy;
-      app->showMainWidget(&dummy);
-    } else {
-      app = (QPEApplication*)qApp;
-    }
-    SDL_QPEAppActive++;
-  }
-  return 0;  
-}
-
-/* Quit the QPE Application, if there's nothing left to do */
-void SDL_QuitQPEApp(void)
-{
-  /* Decrement the application reference count */
-  SDL_QPEAppActive--;
-  /* If the reference count reached zero, clean up the app */
-  if ( SDL_QPEAppActive == 0 && app) {
-    delete app;
-    app = 0;
-    qApp = 0;
-  }
-}
diff --git a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_QWin.cc b/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_QWin.cc
deleted file mode 100644
index 04474ed..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_QWin.cc
+++ /dev/null
@@ -1,527 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include "SDL_QWin.h"
-#include <qapplication.h>
-#include <qdirectpainter_qws.h>
-
-screenRotationT screenRotation = SDL_QT_NO_ROTATION;
-
-SDL_QWin::SDL_QWin(const QSize& size)
-  : QWidget(0, "SDL_main"), my_painter(0), my_image(0),
-    my_inhibit_resize(false), my_mouse_pos(-1,-1), my_flags(0),
-    my_has_fullscreen(false), my_locked(0)
-{
-  setBackgroundMode(NoBackground);
-}
-
-SDL_QWin::~SDL_QWin() {
-  // Nothing to do yet.
-  if(my_image) {
-    delete my_image;
-  }
-}
-
-void SDL_QWin::setImage(QImage *image) {
-  if ( my_image ) {
-    delete my_image;
-  }
-  my_image = image;
-  //  setFixedSize(image->size());
-}
-
-void SDL_QWin::resizeEvent(QResizeEvent *e) {
-  if(size() != qApp->desktop()->size()) {
-    // Widget is not the correct size, so do the fullscreen magic
-    my_has_fullscreen = false;
-    enableFullscreen();
-  }
-  if(my_inhibit_resize) {
-    my_inhibit_resize = false;
-  } else {
-    SDL_PrivateResize(e->size().width(), e->size().height());
-  }
-}
-
-void SDL_QWin::focusInEvent(QFocusEvent *) {
-  // Always do it here, no matter the size.
-  enableFullscreen();
-  SDL_PrivateAppActive(true, SDL_APPINPUTFOCUS);
-}
-
-void SDL_QWin::focusOutEvent(QFocusEvent *) {
-  my_has_fullscreen = false;
-  SDL_PrivateAppActive(false, SDL_APPINPUTFOCUS);
-}
-
-void SDL_QWin::closeEvent(QCloseEvent *e) {
-  SDL_PrivateQuit();
-  e->ignore();
-}
-
-void SDL_QWin::setMousePos(const QPoint &pos) {
-  if(my_image->width() == height()) {
-    if (screenRotation == SDL_QT_ROTATION_90)
-      my_mouse_pos = QPoint(height()-pos.y(), pos.x());
-    else if (screenRotation == SDL_QT_ROTATION_270)
-      my_mouse_pos = QPoint(pos.y(), width()-pos.x());
-  } else {
-    my_mouse_pos = pos;
-  }
-}
-
-void SDL_QWin::mouseMoveEvent(QMouseEvent *e) {
-  Qt::ButtonState button = e->button();
-  int sdlstate = 0;
-  if( (button & Qt::LeftButton)) {
-    sdlstate |= SDL_BUTTON_LMASK;
-  }
-  if( (button & Qt::RightButton)) {
-    sdlstate |= SDL_BUTTON_RMASK;
-  }
-  if( (button & Qt::MidButton)) {
-    sdlstate |= SDL_BUTTON_MMASK;
-  }
-  setMousePos(e->pos());
-  SDL_PrivateMouseMotion(sdlstate, 0, my_mouse_pos.x(), my_mouse_pos.y());
-}
-
-void SDL_QWin::mousePressEvent(QMouseEvent *e) {
-  mouseMoveEvent(e);
-  Qt::ButtonState button = e->button();
-  SDL_PrivateMouseButton(SDL_PRESSED,
-			 (button & Qt::LeftButton) ? 1 :
-			 ((button & Qt::RightButton) ? 2 : 3),
-			 my_mouse_pos.x(), my_mouse_pos.y());
-}
-
-void SDL_QWin::mouseReleaseEvent(QMouseEvent *e) {
-  setMousePos(e->pos());
-  Qt::ButtonState button = e->button();
-  SDL_PrivateMouseButton(SDL_RELEASED,
-			 (button & Qt::LeftButton) ? 1 :
-			 ((button & Qt::RightButton) ? 2 : 3),
-			 my_mouse_pos.x(), my_mouse_pos.y());
-  my_mouse_pos = QPoint(-1, -1);
-}
-
-static inline void
-gs_fastRotateBlit_3 ( unsigned short *fb,
-		      unsigned short *bits,
-		      const QRect& rect )
-{
-  // FIXME: this only works correctly for 240x320 displays
-  int startx, starty;
-  int width, height;
-  
-  startx = rect.left() >> 1;
-  starty = rect.top() >> 1;
-  width  = ((rect.right() - rect.left()) >> 1) + 2;
-  height = ((rect.bottom() - rect.top()) >> 1) + 2;
-
-  if((startx+width) > 120) {
-    width = 120 - startx; // avoid horizontal overflow
-  }
-  if((starty+height) > 160) { 
-    height = 160 - starty; // avoid vertical overflow
-  }
-
-  ulong *sp1, *sp2, *dp1, *dp2;
-  ulong stop, sbot, dtop, dbot;    
-  
-  sp1 = (ulong*)bits + startx + starty*240;
-  sp2 = sp1 + 120;
-  dp1 = (ulong *)fb + (159 - starty) + startx*320;
-  dp2 = dp1 + 160;
-  int rowadd = (-320*width) - 1;
-  int rowadd2 = 240 - width;
-  // transfer in cells of 2x2 pixels in words
-  for (int y=0; y<height; y++) {
-    for (int x=0; x<width; x++) {
-      // read source pixels
-      stop = *sp1;
-      sbot = *sp2;
-      // rotate pixels
-      dtop = (sbot & 0xffff) + ((stop & 0xffff)<<16);
-      dbot = ((sbot & 0xffff0000)>>16) + (stop & 0xffff0000);
-      // write to framebuffer
-      *dp1 = dtop;
-      *dp2 = dbot;
-      // update source ptrs
-      sp1++; sp2++;
-      // update dest ptrs - 2 pix at a time
-      dp1 += 320;
-      dp2 += 320;
-    }
-    // adjust src ptrs - skip a row as we work in pairs
-    sp1 += rowadd2;
-    sp2 += rowadd2;
-    // adjust dest ptrs for rotation
-    dp1 += rowadd;
-    dp2 += rowadd;
-  }
-}
-
-static inline void
-gs_fastRotateBlit_1 ( unsigned short *fb,
-		      unsigned short *bits,
-		      const QRect& rect ) {
-  // FIXME: this only works correctly for 240x320 displays
-  int startx, starty;
-  int width, height;
-
-  startx = rect.left() >> 1;
-  starty = rect.top() >> 1;
-  width  = ((rect.right() - rect.left()) >> 1) + 2;
-  height = ((rect.bottom() - rect.top()) >> 1) + 2;
-
-  if((startx+width) > 120) {
-    width = 120 - startx; // avoid horizontal overflow
-  }
-  if((starty+height) > 160) { 
-    height = 160 - starty; // avoid vertical overflow
-  }
-
-  ulong *sp1, *sp2, *dp1, *dp2;
-  ulong stop, sbot, dtop, dbot;    
-  fb += 320*239; // Move "fb" to top left corner
-  sp1 = (ulong*)bits + startx + starty*240;
-  sp2 = sp1 + 120;
-  dp1 = (ulong*)fb - startx * 320 - starty;
-  dp2 = dp1 - 160;
-  int rowadd = (320*width) + 1;
-  int rowadd2 = 240 - width;
-  // transfer in cells of 2x2 pixels in words
-  for (int y=0; y<height; y++) {
-    for (int x=0; x<width; x++) {
-      // read
-      stop = *sp1;
-      sbot = *sp2;
-      // rotate
-      dtop = (stop & 0xffff) + ((sbot & 0xffff)<<16);
-      dbot = ((stop & 0xffff0000)>>16) + (sbot & 0xffff0000);
-      // write
-      *dp1 = dtop;
-      *dp2 = dbot;
-      // update source ptrs
-      sp1++; sp2++;
-      // update dest ptrs - 2 pix at a time
-      dp1 -= 320;
-      dp2 -= 320;
-    }
-    // adjust src ptrs - skip a row as we work in pairs
-    sp1 += rowadd2;
-    sp2 += rowadd2;
-    // adjust dest ptrs for rotation
-    dp1 += rowadd;
-    dp2 += rowadd;
-  }
-}
-
-// desktop, SL-A300 etc
-bool SDL_QWin::repaintRotation0(const QRect& rect) {
-  if(my_image->width() == width()) {
-    uchar *fb = (uchar*)my_painter->frameBuffer();
-    uchar *buf = (uchar*)my_image->bits();
-    if(rect == my_image->rect()) {
-      SDL_memcpy(fb, buf, width()*height()*2);
-    } else {
-      int h = rect.height();
-      int wd = rect.width()<<1;
-      int fblineadd = my_painter->lineStep();
-      int buflineadd = my_image->bytesPerLine();
-      fb  += (rect.left()<<1) + rect.top() * my_painter->lineStep();
-      buf += (rect.left()<<1) + rect.top() * my_image->bytesPerLine();
-      while(h--) {
-	SDL_memcpy(fb, buf, wd);
-	fb += fblineadd;
-	buf += buflineadd;
-      }
-    }
-  } else {
-    return false; // FIXME: Landscape
-  }
-#ifdef __i386__
-  my_painter->fillRect( rect, QBrush( Qt::NoBrush ) );
-#endif
-  return true;
-}
-
-  
-// Sharp Zaurus SL-5500 etc 
-bool SDL_QWin::repaintRotation3(const QRect& rect) {
-  if(my_image->width() == width()) {
-    ushort *fb = (ushort*)my_painter->frameBuffer();
-    ushort *buf = (ushort*)my_image->bits();
-    gs_fastRotateBlit_3(fb, buf, rect);
-  } else {
-    // landscape mode
-    if (screenRotation == SDL_QT_ROTATION_90) {
-      uchar *fb = (uchar*)my_painter->frameBuffer();
-      uchar *buf = (uchar*)my_image->bits();
-      if(rect == my_image->rect()) {
-	SDL_memcpy(fb, buf, width()*height()*2);
-      } else {
-	int h = rect.height();
-	int wd = rect.width()<<1;
-	int fblineadd = my_painter->lineStep();
-	int buflineadd = my_image->bytesPerLine();
-	fb  += (rect.left()<<1) + rect.top() * my_painter->lineStep();
-	buf += (rect.left()<<1) + rect.top() * my_image->bytesPerLine();
-	while(h--) {
-	  SDL_memcpy(fb, buf, wd);
-	  fb += fblineadd;
-	  buf += buflineadd;
-	}
-      }
-    } else if (screenRotation == SDL_QT_ROTATION_270) {
-      int h = rect.height();
-      int wd = rect.width();
-      int fblineadd = my_painter->lineStep() - (rect.width() << 1);
-      int buflineadd = my_image->bytesPerLine() - (rect.width() << 1);
-      int w;
-
-      uchar *fb = (uchar*)my_painter->frameBuffer();
-      uchar *buf = (uchar*)my_image->bits();
-        
-      fb += ((my_painter->width() - (rect.top() + rect.height())) * 
-	     my_painter->lineStep()) + ((my_painter->height() - ((rect.left() + 
-								  rect.width()))) << 1);
-
-      buf += my_image->bytesPerLine() * (rect.top() + rect.height()) -
-	(((my_image->width() - (rect.left() + rect.width())) << 1) + 2);
-
-      while(h--) {
-	w = wd;
-	while(w--) *((unsigned short*)fb)++ = *((unsigned short*)buf)--;
-	fb += fblineadd;
-	buf -= buflineadd;
-      }
-    }
-  }
-  return true;
-}
-
-// ipaq 3800...
-bool SDL_QWin::repaintRotation1(const QRect& rect) {
-  if(my_image->width() == width()) {
-    ushort *fb = (ushort*)my_painter->frameBuffer();
-    ushort *buf = (ushort*)my_image->bits();
-    gs_fastRotateBlit_1(fb, buf, rect);
-  } else {
-    return false; // FIXME: landscape mode
-  }
-  return true;
-}
-
-void SDL_QWin::repaintRect(const QRect& rect) {
-  if(!my_painter || !rect.width() || !rect.height()) {
-    return;
-  }
-  
-  if(QPixmap::defaultDepth() == 16) {
-    switch(my_painter->transformOrientation()) {
-    case 3:
-      if(repaintRotation3(rect)) { return;  }
-      break;
-    case 1:
-      if(repaintRotation1(rect)) { return;  }
-      break;
-    case 0:
-      if(repaintRotation0(rect)) { return;  }
-      break;
-    }
-  } 
-  my_painter->drawImage(rect.topLeft(), *my_image, rect);
-}
-
-// This paints the current buffer to the screen, when desired. 
-void SDL_QWin::paintEvent(QPaintEvent *ev) {  
-  if(my_image) {
-    lockScreen(true);
-    repaintRect(ev->rect());
-    unlockScreen();
-  }
-}  
-
-/* Function to translate a keyboard transition and queue the key event
- * This should probably be a table although this method isn't exactly
- * slow.
- */
-void SDL_QWin::QueueKey(QKeyEvent *e, int pressed)
-{  
-  SDL_keysym keysym;
-  int scancode = e->key();
-  /* Set the keysym information */
-  if(scancode >= 'A' && scancode <= 'Z') {
-    // Qt sends uppercase, SDL wants lowercase
-    keysym.sym = static_cast<SDLKey>(scancode + 32);
-  } else if(scancode  >= 0x1000) {
-    // Special keys
-    switch(scancode) {
-    case Qt::Key_Escape: scancode = SDLK_ESCAPE; break;
-    case Qt::Key_Tab: scancode = SDLK_TAB; break;
-    case Qt::Key_Backspace: scancode = SDLK_BACKSPACE; break;
-    case Qt::Key_Return: scancode = SDLK_RETURN; break;
-    case Qt::Key_Enter: scancode = SDLK_KP_ENTER; break;
-    case Qt::Key_Insert: scancode = SDLK_INSERT; break;
-    case Qt::Key_Delete: scancode = SDLK_DELETE; break;
-    case Qt::Key_Pause: scancode = SDLK_PAUSE; break;
-    case Qt::Key_Print: scancode = SDLK_PRINT; break;
-    case Qt::Key_SysReq: scancode = SDLK_SYSREQ; break;
-    case Qt::Key_Home: scancode = SDLK_HOME; break;
-    case Qt::Key_End: scancode = SDLK_END; break;
-    // We want the control keys to rotate with the screen
-    case Qt::Key_Left: 
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_UP;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_DOWN;
-        else scancode = SDLK_LEFT;
-        break;
-    case Qt::Key_Up: 
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_RIGHT;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_LEFT;
-        else scancode = SDLK_UP;
-        break;
-    case Qt::Key_Right: 
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_DOWN;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_UP;
-        else scancode = SDLK_RIGHT;
-        break;
-    case Qt::Key_Down:
-        if (screenRotation == SDL_QT_ROTATION_90) scancode = SDLK_LEFT;
-        else if (screenRotation == SDL_QT_ROTATION_270) scancode = SDLK_RIGHT;
-        else scancode = SDLK_DOWN;
-        break;
-    case Qt::Key_Prior: scancode = SDLK_PAGEUP; break;
-    case Qt::Key_Next: scancode = SDLK_PAGEDOWN; break;
-    case Qt::Key_Shift: scancode = SDLK_LSHIFT; break;
-    case Qt::Key_Control: scancode = SDLK_LCTRL; break;
-    case Qt::Key_Meta: scancode = SDLK_LMETA; break;
-    case Qt::Key_Alt: scancode = SDLK_LALT; break;
-    case Qt::Key_CapsLock: scancode = SDLK_CAPSLOCK; break;
-    case Qt::Key_NumLock: scancode = SDLK_NUMLOCK; break;
-    case Qt::Key_ScrollLock: scancode = SDLK_SCROLLOCK; break;
-    case Qt::Key_F1: scancode = SDLK_F1; break;
-    case Qt::Key_F2: scancode = SDLK_F2; break;
-    case Qt::Key_F3: scancode = SDLK_F3; break;
-    case Qt::Key_F4: scancode = SDLK_F4; break;
-    case Qt::Key_F5: scancode = SDLK_F5; break;
-    case Qt::Key_F6: scancode = SDLK_F6; break;
-    case Qt::Key_F7: scancode = SDLK_F7; break;
-    case Qt::Key_F8: scancode = SDLK_F8; break;
-    case Qt::Key_F9: scancode = SDLK_F9; break;
-    case Qt::Key_F10: scancode = SDLK_F10; break;
-    case Qt::Key_F11: scancode = SDLK_F11; break;
-    case Qt::Key_F12: scancode = SDLK_F12; break;
-    case Qt::Key_F13: scancode = SDLK_F13; break;
-    case Qt::Key_F14: scancode = SDLK_F14; break;
-    case Qt::Key_F15: scancode = SDLK_F15; break;
-    case Qt::Key_Super_L: scancode = SDLK_LSUPER; break;
-    case Qt::Key_Super_R: scancode = SDLK_RSUPER; break;
-    case Qt::Key_Menu: scancode = SDLK_MENU; break;
-    case Qt::Key_Help: scancode = SDLK_HELP; break;
-
-    case Qt::Key_F33:
-      // FIXME: This is a hack to enable the OK key on
-      // Zaurii devices. SDLK_RETURN is a suitable key to use
-      // since it often is used as such.
-      //     david@hedbor.org
-      scancode = SDLK_RETURN;
-      break;
-    default:
-      scancode = SDLK_UNKNOWN;
-      break;
-    }
-    keysym.sym = static_cast<SDLKey>(scancode);    
-  } else {
-    keysym.sym = static_cast<SDLKey>(scancode);    
-  }
-  keysym.scancode = scancode;
-  keysym.mod = KMOD_NONE;
-  ButtonState st = e->state();
-  if( (st & ShiftButton) )   { keysym.mod = static_cast<SDLMod>(keysym.mod | KMOD_LSHIFT);  }
-  if( (st & ControlButton) ) { keysym.mod = static_cast<SDLMod>(keysym.mod | KMOD_LCTRL);  }
-  if( (st & AltButton) )     { keysym.mod = static_cast<SDLMod>(keysym.mod | KMOD_LALT);  }
-  if ( SDL_TranslateUNICODE ) {
-    QChar qchar = e->text()[0];
-    keysym.unicode = qchar.unicode();
-  } else {
-    keysym.unicode = 0;
-  }
-
-  /* NUMLOCK and CAPSLOCK are implemented as double-presses in reality */
-  //	if ( (keysym.sym == SDLK_NUMLOCK) || (keysym.sym == SDLK_CAPSLOCK) ) {
-  //		pressed = 1;
-  //	}
-
-  /* Queue the key event */
-  if ( pressed ) {
-    SDL_PrivateKeyboard(SDL_PRESSED, &keysym);
-  } else {
-    SDL_PrivateKeyboard(SDL_RELEASED, &keysym);
-  }
-}
-
-void SDL_QWin::setFullscreen(bool fs_on) {
-  my_has_fullscreen = false;
-  enableFullscreen();
-}
-
-void SDL_QWin::enableFullscreen() {
-  // Make sure size is correct
-  if(!my_has_fullscreen) {
-    setFixedSize(qApp->desktop()->size());
-    // This call is needed because showFullScreen won't work
-    // correctly if the widget already considers itself to be fullscreen.
-    showNormal();
-    // This is needed because showNormal() forcefully changes the window
-    // style to WSTyle_TopLevel.
-    setWFlags(WStyle_Customize | WStyle_NoBorder);
-    // Enable fullscreen.
-    showFullScreen();
-    my_has_fullscreen = true;
-  }
-}
-
-bool SDL_QWin::lockScreen(bool force) {
-  if(!my_painter) {
-    if(force || (isVisible() && isActiveWindow())) {
-      my_painter = new QDirectPainter(this);
-    } else {
-      return false;
-    }
-  }
-  my_locked++; // Increate lock refcount
-  return true;
-}
-
-void SDL_QWin::unlockScreen() {
-  if(my_locked > 0) {
-    my_locked--; // decrease lock refcount;
-  }
-  if(!my_locked && my_painter) {
-    my_painter->end();
-    delete my_painter;
-    my_painter = 0;
-  }
-}
diff --git a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysevents.cc b/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysevents.cc
deleted file mode 100644
index 4aaf814..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysevents.cc
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include <qpe/qpeapplication.h>
-
-#include <stdio.h>
-#include <string.h>
-#include "SDL_error.h"
-#include "SDL_events.h"
-#include "SDL_QWin.h"
-#include "SDL_lowvideo.h"
-#include "SDL_timer.h"
-
-extern "C" {
-#include "../../events/SDL_sysevents.h"
-#include "../../events/SDL_events_c.h"
-#include "SDL_sysevents_c.h"
-
-  //  static SDLKey keymap[128];
-/* This is special because we know it will be run in a loop in a separate
-   thread.  Normally this function should loop as long as there are input
-   states changing, i.e. new events arriving.
-*/
-void QT_PumpEvents(_THIS)
-{
-  if(!qApp) {
-    return; 
-  }
-  //  printf("processing events: %p\n", qApp);
-  //qApp->processOneEvent(); // wait for a event
-  qApp->processEvents(); // and process all outstanding ones
-#if 0
-  BView *view;
-	BRect bounds;
-	BPoint point;
-	uint32 buttons;
-	const uint32 button_masks[3] = {
-		B_PRIMARY_MOUSE_BUTTON,
-		B_TERTIARY_MOUSE_BUTTON, 
-		B_SECONDARY_MOUSE_BUTTON,
-	};
-	unsigned int    i, j;
-
-	/* Check out the mouse buttons and position (slight race condition) */
-	if ( SDL_Win->Lock() ) {
-		/* Don't do anything if we have no view */
-		view = SDL_Win->View();
-		if ( ! view ) {
-			SDL_Win->Unlock();
-			return;
-		}
-		bounds = view->Bounds();
-		/* Get new input state, if still active */
-		if ( SDL_Win->IsActive() ) {
-			key_flip = !key_flip;
-			get_key_info(&keyinfo[key_flip]);
-			view->GetMouse(&point, &buttons, true);
-		} else {
-			key_flip = key_flip;
-			point = last_point;
-			buttons = last_buttons;
-		}
-		SDL_Win->Unlock();
-	} else {
-		return;
-	}
-
-	/* If our view is active, we'll find key changes here */
-	if ( SDL_memcmp(keyinfo[0].key_states, keyinfo[1].key_states, 16) != 0 ) {
-		for ( i=0; i<16; ++i ) {
-			Uint8 new_state, transition;
-
-			new_state = keyinfo[key_flip].key_states[i];
-			transition = keyinfo[!key_flip].key_states[i] ^
-					keyinfo[ key_flip].key_states[i];
-			for ( j=0; j<8; ++j ) {
-				if ( transition&0x80 )
-					QueueKey(i*8+j, new_state&0x80);
-				transition <<= 1;
-				new_state <<= 1;
-			}
-		}
-	}
-
-	/* We check keyboard, but not mouse if mouse isn't in window */
-	if ( ! bounds.Contains(point) ) {
-		/* Mouse moved outside our view? */
-		if ( SDL_GetAppState() & SDL_APPMOUSEFOCUS ) {
-			SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
-			be_app->SetCursor(B_HAND_CURSOR);
-		}
-		return;
-	}
-	/* Has the mouse moved back into our view? */
-	if ( ! (SDL_GetAppState() & SDL_APPMOUSEFOCUS) ) {
-		/* Reset the B_HAND_CURSOR to our own */
-		SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
-		SDL_SetCursor(NULL);
-	}
-
-	/* Check for mouse motion */
-	if ( point != last_point ) {
-		int x, y;
-
-		SDL_Win->GetXYOffset(x, y);
-		x = (int)point.x - x;
-		y = (int)point.y - y;
-		SDL_PrivateMouseMotion(0, 0, x, y);
-	}
-	last_point = point;
-
-	/* Add any mouse button events */
-	for ( i=0; i<SDL_TABLESIZE(button_masks); ++i ) {
-		if ( (buttons ^ last_buttons) & button_masks[i] ) {
-			if ( buttons & button_masks[i] ) {
-				SDL_PrivateMouseButton(SDL_PRESSED, 1+i, 0, 0);
-			} else {
-				SDL_PrivateMouseButton(SDL_RELEASED, 1+i, 0, 0);
-			}
-		}
-	}
-	last_buttons = buttons;
-#endif
-}
-
-void QT_InitOSKeymap(_THIS)
-{
-#if 0
-  unsigned int i;
-
-  /* Initialize all the key states as "up" */
-  key_flip = 0;
-  SDL_memset(keyinfo[key_flip].key_states, 0, 16);
-
-  /* Initialize the key translation table */
-  for ( i=0; i<SDL_TABLESIZE(keymap); ++i )
-    keymap[i] = SDLK_UNKNOWN;
-
-  //  keymap[0x01]		= SDLK_ESCAPE;
-  //  keymap[B_F1_KEY]	= SDLK_F1;
-  //  keymap[B_F2_KEY]	= SDLK_F2;
-  //  keymap[B_F3_KEY]	= SDLK_F3;
-  //  keymap[B_F4_KEY]	= SDLK_F4;
-  //  keymap[B_F5_KEY]	= SDLK_F5;
-  //  keymap[B_F6_KEY]	= SDLK_F6;
-  //  keymap[B_F7_KEY]	= SDLK_F7;
-  //  keymap[B_F8_KEY]	= SDLK_F8;
-  //  keymap[B_F9_KEY]	= SDLK_F9;
-  //  keymap[B_F10_KEY]	= SDLK_F10;
-  //  keymap[B_F11_KEY]	= SDLK_F11;
-  //  keymap[B_F12_KEY]	= SDLK_F12;
-  //  keymap[B_PRINT_KEY]	= SDLK_PRINT;
-  //keymap[B_SCROLL_KEY]	= SDLK_SCROLLOCK;
-  //  keymap[B_PAUSE_KEY]	= SDLK_PAUSE;
-  keymap[0x11]		= SDLK_BACKQUOTE;
-  keymap[0x12]		= SDLK_1;
-  keymap[0x13]		= SDLK_2;
-  keymap[0x14]		= SDLK_3;
-  keymap[0x15]		= SDLK_4;
-  keymap[0x16]		= SDLK_5;
-  keymap[0x17]		= SDLK_6;
-  keymap[0x18]		= SDLK_7;
-  keymap[0x19]		= SDLK_8;
-  keymap[0x1a]		= SDLK_9;
-  keymap[0x1b]		= SDLK_0;
-  keymap[0x1c]		= SDLK_MINUS;
-  keymap[0x1d]		= SDLK_EQUALS;
-  keymap[0x1e]		= SDLK_BACKSPACE;
-  keymap[0x1f]		= SDLK_INSERT;
-  keymap[0x20]		= SDLK_HOME;
-  keymap[0x21]		= SDLK_PAGEUP;
-  //keymap[0x22]		= SDLK_NUMLOCK;
-  keymap[0x23]		= SDLK_KP_DIVIDE;
-  keymap[0x24]		= SDLK_KP_MULTIPLY;
-  keymap[0x25]		= SDLK_KP_MINUS;
-  keymap[0x26]		= SDLK_TAB;
-  keymap[0x27]		= SDLK_q;
-  keymap[0x28]		= SDLK_w;
-  keymap[0x29]		= SDLK_e;
-  keymap[0x2a]		= SDLK_r;
-  keymap[0x2b]		= SDLK_t;
-  keymap[0x2c]		= SDLK_y;
-  keymap[0x2d]		= SDLK_u;
-  keymap[0x2e]		= SDLK_i;
-  keymap[0x2f]		= SDLK_o;
-  keymap[0x30]		= SDLK_p;
-  keymap[0x31]		= SDLK_LEFTBRACKET;
-  keymap[0x32]		= SDLK_RIGHTBRACKET;
-  keymap[0x33]		= SDLK_BACKSLASH;
-  keymap[0x34]		= SDLK_DELETE;
-  keymap[0x35]		= SDLK_END;
-  keymap[0x36]		= SDLK_PAGEDOWN;
-  keymap[0x37]		= SDLK_KP7;
-  keymap[0x38]		= SDLK_KP8;
-  keymap[0x39]		= SDLK_KP9;
-  keymap[0x3a]		= SDLK_KP_PLUS;
-  //keymap[0x3b]		= SDLK_CAPSLOCK;
-  keymap[0x3c]		= SDLK_a;
-  keymap[0x3d]		= SDLK_s;
-  keymap[0x3e]		= SDLK_d;
-  keymap[0x3f]		= SDLK_f;
-  keymap[0x40]		= SDLK_g;
-  keymap[0x41]		= SDLK_h;
-  keymap[0x42]		= SDLK_j;
-  keymap[0x43]		= SDLK_k;
-  keymap[0x44]		= SDLK_l;
-  keymap[0x45]		= SDLK_SEMICOLON;
-  keymap[0x46]		= SDLK_QUOTE;
-  keymap[0x47]		= SDLK_RETURN;
-  keymap[0x48]		= SDLK_KP4;
-  keymap[0x49]		= SDLK_KP5;
-  keymap[0x4a]		= SDLK_KP6;
-  keymap[0x4b]		= SDLK_LSHIFT;
-  keymap[0x4c]		= SDLK_z;
-  keymap[0x4d]		= SDLK_x;
-  keymap[0x4e]		= SDLK_c;
-  keymap[0x4f]		= SDLK_v;
-  keymap[0x50]		= SDLK_b;
-  keymap[0x51]		= SDLK_n;
-  keymap[0x52]		= SDLK_m;
-  keymap[0x53]		= SDLK_COMMA;
-  keymap[0x54]		= SDLK_PERIOD;
-  keymap[0x55]		= SDLK_SLASH;
-  keymap[0x56]		= SDLK_RSHIFT;
-  keymap[0x57]		= SDLK_UP;
-  keymap[0x58]		= SDLK_KP1;
-  keymap[0x59]		= SDLK_KP2;
-  keymap[0x5a]		= SDLK_KP3;
-  keymap[0x5b]		= SDLK_KP_ENTER;
-  //keymap[0x5c]		= SDLK_LCTRL;
-  //keymap[0x5d]		= SDLK_LALT;
-  keymap[0x5e]		= SDLK_SPACE;
-  //keymap[0x5f]		= SDLK_RALT;
-  //keymap[0x60]		= SDLK_RCTRL;
-  keymap[0x61]		= SDLK_LEFT;
-  keymap[0x62]		= SDLK_DOWN;
-  keymap[0x63]		= SDLK_RIGHT;
-  keymap[0x64]		= SDLK_KP0;
-  keymap[0x65]		= SDLK_KP_PERIOD;
-  //keymap[0x66]		= SDLK_LMETA;
-  //keymap[0x67]		= SDLK_RMETA;
-  //keymap[0x68]		= SDLK_MENU;
-  keymap[0x69]		= SDLK_EURO;
-  keymap[0x6a]		= SDLK_KP_EQUALS;
-  keymap[0x6b]		= SDLK_POWER;
-#endif
-}
-
-}; /* Extern C */
diff --git a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysmouse.cc b/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysmouse.cc
deleted file mode 100644
index 1a655b6..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysmouse.cc
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include "SDL_QWin.h"
-
-extern "C" {
-
-#include "SDL_sysmouse_c.h"
-
-/* The implementation dependent data for the window manager cursor */
-struct WMcursor {
-	char *bits;
-};
-WMcursor *QT_CreateWMCursor(_THIS,
-		Uint8 *data, Uint8 *mask, int w, int h, int hot_x, int hot_y)
-{
-  static WMcursor dummy;
-  dummy.bits = 0;
-  return &dummy;
-}
-
-int QT_ShowWMCursor(_THIS, WMcursor *cursor)
-{
-  return 1;
-}
-
-void QT_FreeWMCursor(_THIS, WMcursor *cursor)
-{
-}
-
-void QT_WarpWMCursor(_THIS, Uint16 x, Uint16 y)
-{
-  SDL_Win->setMousePos(QPoint(x, y));
-}
-
-}; /* Extern C */
diff --git a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysvideo.cc b/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysvideo.cc
deleted file mode 100644
index 0e07874..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_sysvideo.cc
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-/* Qtopia based framebuffer implementation */
-
-#include <unistd.h>
-
-#include <qapplication.h>
-#include <qpe/qpeapplication.h>
-
-#include "SDL_timer.h"
-
-#include "SDL_QWin.h"
-
-extern "C" {
-
-#include "../SDL_sysvideo.h"
-#include "../../events/SDL_events_c.h"
-#include "SDL_sysevents_c.h"
-#include "SDL_sysmouse_c.h"
-#include "SDL_syswm_c.h"
-#include "SDL_lowvideo.h"
-
-  //#define QTOPIA_DEBUG
-#define QT_HIDDEN_SIZE	32	/* starting hidden window size */
-
-  /* Name of the environment variable used to invert the screen rotation or not:
-     Possible values:
-     !=0 : Screen is 270 rotated
-     0: Screen is 90 rotated*/
-#define SDL_QT_ROTATION_ENV_NAME "SDL_QT_INVERT_ROTATION"
-  
-  /* Initialization/Query functions */
-  static int QT_VideoInit(_THIS, SDL_PixelFormat *vformat);
-  static SDL_Rect **QT_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags);
-  static SDL_Surface *QT_SetVideoMode(_THIS, SDL_Surface *current, int width, int height, int bpp, Uint32 flags);
-  static void QT_UpdateMouse(_THIS);
-  static int QT_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors);
-  static void QT_VideoQuit(_THIS);
-
-  /* Hardware surface functions */
-  static int QT_AllocHWSurface(_THIS, SDL_Surface *surface);
-  static int QT_LockHWSurface(_THIS, SDL_Surface *surface);
-  static void QT_UnlockHWSurface(_THIS, SDL_Surface *surface);
-  static void QT_FreeHWSurface(_THIS, SDL_Surface *surface);
-
-  static int QT_ToggleFullScreen(_THIS, int fullscreen);
-
-  static int QT_IconifyWindow(_THIS);
-  static SDL_GrabMode QT_GrabInput(_THIS, SDL_GrabMode mode);
-
-  /* FB driver bootstrap functions */
-
-  static int QT_Available(void)
-  {
-    return(1);
-  }
-
-  static void QT_DeleteDevice(SDL_VideoDevice *device)
-  {
-    SDL_free(device->hidden);
-    SDL_free(device);
-  }
-
-  static SDL_VideoDevice *QT_CreateDevice(int devindex)
-  {
-    SDL_VideoDevice *device;
-
-    /* Initialize all variables that we clean on shutdown */
-    device = (SDL_VideoDevice *)SDL_malloc(sizeof(SDL_VideoDevice));
-    if ( device ) {
-      SDL_memset(device, 0, (sizeof *device));
-      device->hidden = (struct SDL_PrivateVideoData *)
-	SDL_malloc((sizeof *device->hidden));
-    }
-    if ( (device == NULL) || (device->hidden == NULL) ) {
-      SDL_OutOfMemory();
-      if ( device ) {
-	SDL_free(device);
-      }
-      return(0);
-    }
-    SDL_memset(device->hidden, 0, (sizeof *device->hidden));
-
-    /* Set the function pointers */
-    device->VideoInit = QT_VideoInit;
-    device->ListModes = QT_ListModes;
-    device->SetVideoMode = QT_SetVideoMode;
-    device->UpdateMouse = QT_UpdateMouse;
-    device->SetColors = QT_SetColors;
-    device->UpdateRects = NULL;
-    device->VideoQuit = QT_VideoQuit;
-    device->AllocHWSurface = QT_AllocHWSurface;
-    device->CheckHWBlit = NULL;
-    device->FillHWRect = NULL;
-    device->SetHWColorKey = NULL;
-    device->SetHWAlpha = NULL;
-    device->LockHWSurface = QT_LockHWSurface;
-    device->UnlockHWSurface = QT_UnlockHWSurface;
-    device->FlipHWSurface = NULL;
-    device->FreeHWSurface = QT_FreeHWSurface;
-    device->SetIcon = NULL;
-    device->SetCaption = QT_SetWMCaption;
-    device->IconifyWindow = QT_IconifyWindow;
-    device->GrabInput = QT_GrabInput;
-    device->GetWMInfo = NULL;
-    device->FreeWMCursor = QT_FreeWMCursor;
-    device->CreateWMCursor = QT_CreateWMCursor;
-    device->ShowWMCursor = QT_ShowWMCursor;
-    device->WarpWMCursor = QT_WarpWMCursor;
-    device->InitOSKeymap = QT_InitOSKeymap;
-    device->PumpEvents = QT_PumpEvents;
-
-    device->free = QT_DeleteDevice;
-    device->ToggleFullScreen = QT_ToggleFullScreen;
-
-    /* Set the driver flags */
-    device->handles_any_size = 0;
-	
-    return device;
-  }
-
-  VideoBootStrap Qtopia_bootstrap = {
-    "qtopia", "Qtopia / QPE graphics",
-    QT_Available, QT_CreateDevice
-  };
-
-  /* Function to sort the display_list */
-  static int CompareModes(const void *A, const void *B)
-  {
-#if 0
-    const display_mode *a = (display_mode *)A;
-    const display_mode *b = (display_mode *)B;
-
-    if ( a->space == b->space ) {
-      return((b->virtual_width*b->virtual_height)-
-	     (a->virtual_width*a->virtual_height));
-    } else {
-      return(ColorSpaceToBitsPerPixel(b->space)-
-	     ColorSpaceToBitsPerPixel(a->space));
-    }
-#endif
-    return 0;
-  }
-
-  /* Yes, this isn't the fastest it could be, but it works nicely */
-  static int QT_AddMode(_THIS, int index, unsigned int w, unsigned int h)
-  {
-    SDL_Rect *mode;
-    int i;
-    int next_mode;
-
-    /* Check to see if we already have this mode */
-    if ( SDL_nummodes[index] > 0 ) {
-      for ( i=SDL_nummodes[index]-1; i >= 0; --i ) {
-	mode = SDL_modelist[index][i];
-	if ( (mode->w == w) && (mode->h == h) ) {
-	  return(0);
-	}
-      }
-    }
-
-    /* Set up the new video mode rectangle */
-    mode = (SDL_Rect *)SDL_malloc(sizeof *mode);
-    if ( mode == NULL ) {
-      SDL_OutOfMemory();
-      return(-1);
-    }
-    mode->x = 0;
-    mode->y = 0;
-    mode->w = w;
-    mode->h = h;
-#ifdef QTOPIA_DEBUG
-    fprintf(stderr, "Adding mode %dx%d at %d bytes per pixel\n", w, h, index+1);
-#endif
-
-    /* Allocate the new list of modes, and fill in the new mode */
-    next_mode = SDL_nummodes[index];
-    SDL_modelist[index] = (SDL_Rect **)
-      SDL_realloc(SDL_modelist[index], (1+next_mode+1)*sizeof(SDL_Rect *));
-    if ( SDL_modelist[index] == NULL ) {
-      SDL_OutOfMemory();
-      SDL_nummodes[index] = 0;
-      SDL_free(mode);
-      return(-1);
-    }
-    SDL_modelist[index][next_mode] = mode;
-    SDL_modelist[index][next_mode+1] = NULL;
-    SDL_nummodes[index]++;
-
-    return(0);
-  }
-
-  int QT_VideoInit(_THIS, SDL_PixelFormat *vformat)
-  {
-    /* Initialize the QPE Application  */
-     /* Determine the screen depth */
-    vformat->BitsPerPixel = QPixmap::defaultDepth();
-
-    // For now we hardcode the current depth because anything else
-    // might as well be emulated by SDL rather than by Qtopia.
-    
-    QSize desktop_size = qApp->desktop()->size();
-    QT_AddMode(_this, ((vformat->BitsPerPixel+7)/8)-1,
-	       desktop_size.width(), desktop_size.height());
-    QT_AddMode(_this, ((vformat->BitsPerPixel+7)/8)-1,
-	       desktop_size.height(), desktop_size.width());
-
-    /* Determine the current screen size */
-    _this->info.current_w = desktop_size.width();
-    _this->info.current_h = desktop_size.height();
-
-    /* Create the window / widget */
-    SDL_Win = new SDL_QWin(QSize(QT_HIDDEN_SIZE, QT_HIDDEN_SIZE));
-    ((QPEApplication*)qApp)->showMainWidget(SDL_Win);
-    /* Fill in some window manager capabilities */
-    _this->info.wm_available = 0;
-
-    /* We're done! */
-    return(0);
-  }
-
-  /* We support any dimension at our bit-depth */
-  SDL_Rect **QT_ListModes(_THIS, SDL_PixelFormat *format, Uint32 flags)
-  {
-    SDL_Rect **modes;
-
-    modes = ((SDL_Rect **)0);
-    if ( (flags & SDL_FULLSCREEN) == SDL_FULLSCREEN ) {
-      modes = SDL_modelist[((format->BitsPerPixel+7)/8)-1];
-    } else {
-      if ( format->BitsPerPixel ==
-	   _this->screen->format->BitsPerPixel ) {
-	modes = ((SDL_Rect **)-1);
-      }
-    }
-    return(modes);
-  }
-
-  /* Various screen update functions available */
-  static void QT_NormalUpdate(_THIS, int numrects, SDL_Rect *rects);
-
-
-  static int QT_SetFullScreen(_THIS, SDL_Surface *screen, int fullscreen)
-  {
-    return -1;
-  }
-
-  static int QT_ToggleFullScreen(_THIS, int fullscreen)
-  {
-    return -1;
-  }
-
-  /* FIXME: check return values and cleanup here */
-  SDL_Surface *QT_SetVideoMode(_THIS, SDL_Surface *current,
-			       int width, int height, int bpp, Uint32 flags)
-  {
-
-    QImage *qimage;
-    QSize desktop_size = qApp->desktop()->size();
-
-    
-    current->flags = 0; //SDL_FULLSCREEN; // We always run fullscreen.
-
-    if(width <= desktop_size.width()
-	      && height <= desktop_size.height()) {
-      current->w = desktop_size.width();
-      current->h = desktop_size.height();
-    } else if(width <= desktop_size.height() && height <= desktop_size.width()) {
-      // Landscape mode
-      char * envString = SDL_getenv(SDL_QT_ROTATION_ENV_NAME);
-      int envValue = envString ? atoi(envString) : 0;
-      screenRotation = envValue ? SDL_QT_ROTATION_270 : SDL_QT_ROTATION_90;
-      current->h = desktop_size.width();
-      current->w = desktop_size.height();
-    } else {
-      SDL_SetError("Unsupported resolution, %dx%d\n", width, height);
-    }
-    if ( flags & SDL_OPENGL ) {
-      SDL_SetError("OpenGL not supported");
-      return(NULL);
-    } 
-    /* Create the QImage framebuffer */
-    qimage = new QImage(current->w, current->h, bpp);
-    if (qimage->isNull()) {
-      SDL_SetError("Couldn't create screen bitmap");
-      delete qimage;
-      return(NULL);
-    }
-    current->pitch = qimage->bytesPerLine();
-    current->pixels = (void *)qimage->bits();
-    SDL_Win->setImage(qimage);
-    _this->UpdateRects = QT_NormalUpdate;
-    SDL_Win->setFullscreen(true);
-    /* We're done */
-    return(current);
-  }
-
-  /* Update the current mouse state and position */
-  void QT_UpdateMouse(_THIS)
-  {
-    QPoint point(-1, -1);
-    if ( SDL_Win->isActiveWindow() ) {
-      point = SDL_Win->mousePos();
-    }
-    
-    if ( (point.x() >= 0) && (point.x() < SDL_VideoSurface->w) &&
-	 (point.y() >= 0) && (point.y() < SDL_VideoSurface->h) ) {
-      SDL_PrivateAppActive(1, SDL_APPMOUSEFOCUS);
-      SDL_PrivateMouseMotion(0, 0,
-			     (Sint16)point.x(), (Sint16)point.y());
-    } else {
-      SDL_PrivateAppActive(0, SDL_APPMOUSEFOCUS);
-    }
-  }
-
-  /* We don't actually allow hardware surfaces other than the main one */
-  static int QT_AllocHWSurface(_THIS, SDL_Surface *surface)
-  {
-    return(-1);
-  }
-  static void QT_FreeHWSurface(_THIS, SDL_Surface *surface)
-  {
-    return;
-  }
-  static int QT_LockHWSurface(_THIS, SDL_Surface *surface)
-  {
-    return(0);
-  }
-  static void QT_UnlockHWSurface(_THIS, SDL_Surface *surface)
-  {
-    return;
-  }
-
-  static void QT_NormalUpdate(_THIS, int numrects, SDL_Rect *rects)
-  {
-    if(SDL_Win->lockScreen()) {
-      for(int i=0; i<numrects; ++i ) {
-	QRect rect(rects[i].x, rects[i].y,
-		   rects[i].w, rects[i].h);
-	SDL_Win->repaintRect(rect);
-      }
-      SDL_Win->unlockScreen();
-    }
-  }
-  /* Is the system palette settable? */
-  int QT_SetColors(_THIS, int firstcolor, int ncolors, SDL_Color *colors)
-  {
-    return -1;
-  }
-
-  void QT_VideoQuit(_THIS)
-  {
-    // This is dumb, but if I free this, the app doesn't exit correctly.
-    // Of course, this will leak memory if init video is done more than once.
-    // Sucks but such is life.
-    
-    //    -- David Hedbor
-    //    delete SDL_Win; 
-    //    SDL_Win = 0;
-    _this->screen->pixels = NULL;
-    QT_GrabInput(_this, SDL_GRAB_OFF);
-  }
-
-  static int QT_IconifyWindow(_THIS) {
-    SDL_Win->hide();
-    
-    return true;
-  }
-
-  static SDL_GrabMode QT_GrabInput(_THIS, SDL_GrabMode mode) {
-    if(mode == SDL_GRAB_OFF) {
-      QPEApplication::grabKeyboard();
-      qApp->processEvents();
-      QPEApplication::ungrabKeyboard();
-    } else {
-      QPEApplication::grabKeyboard();
-    }
-    qApp->processEvents();
-    return mode;
-  }
-  
-}; /* Extern C */
diff --git a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_syswm.cc b/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_syswm.cc
deleted file mode 100644
index 47f988f..0000000
--- a/ale/liblocal/SDL-1.2.15/src/video/qtopia/SDL_syswm.cc
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
-    SDL - Simple DirectMedia Layer
-    Copyright (C) 1997-2012 Sam Lantinga
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
-*/
-#include "SDL_config.h"
-
-#include "SDL_QWin.h"
-
-extern "C" {
-
-#include "SDL_syswm_c.h"
-
-void QT_SetWMCaption(_THIS, const char *title, const char *icon)
-{
-	SDL_Win->setCaption(title);
-}
-
-}; /* Extern C */
diff --git a/rl_agent/src/Agent/ModelBasedAgent.cc b/rl_agent/src/Agent/ModelBasedAgent.cc
index 80189e4..ba11755 100755
--- a/rl_agent/src/Agent/ModelBasedAgent.cc
+++ b/rl_agent/src/Agent/ModelBasedAgent.cc
@@ -104,10 +104,10 @@ void ModelBasedAgent::initParams(){
   
   BATCH_FREQ = 1; //50;
 
-  TIMEDEBUG = false; //true;
+  TIMEDEBUG = false;
   AGENTDEBUG = false;
-  ACTDEBUG = false;//true;
-  SIMPLEDEBUG = false; //true; //false; //true;
+  ACTDEBUG = false;
+  SIMPLEDEBUG = false;
 
   // check
   if (qmax <= 0.1 && (exploreType == TWO_MODE_PLUS_R || 
diff --git a/rl_common/include/rl_common/core.hh b/rl_common/include/rl_common/core.hh
index 56d9016..a3148ee 100644
--- a/rl_common/include/rl_common/core.hh
+++ b/rl_common/include/rl_common/core.hh
@@ -34,6 +34,7 @@
 #define GPTREE      14
 #define CONSTANT    15
 
+
 const std::string modelNames[] = {
   "Tabular",
   "SLF",
@@ -236,6 +237,27 @@ public:
 
   virtual ~Environment() {};
 
+  /** Methods from Arcade, declared here. */
+  virtual void getDiscretization(std::vector<int> *statesPerDim) {};
+  virtual std::vector<ModelSpecification>& getModelSpecs() {return modelSpecs;};
+  virtual char* getEnvironmentDescription() {return NULL;};
+  virtual bool invalidStateChange(int lastAction) {return false;};
+
+  long totalScore;
+
+  /**
+   * Initialize totalScore for possible child class here.
+   */
+  Environment(int stateSpaceLen): totalScore(0), stateSpaceLength(stateSpaceLen), state(stateSpaceLength),
+		  modelSpecs(stateSpaceLength + 3) {}
+
+  Environment():totalScore(0), stateSpaceLength(1), state(stateSpaceLength),
+		  modelSpecs(stateSpaceLength + 3) {}
+
+protected:
+  int stateSpaceLength;
+  std::vector<ModelSpecification> modelSpecs;
+  std::vector<float> state;
 };
 
 /** Interface for an agent.  Implementations of the Agent interface
diff --git a/rl_env/include/rl_env/Arcade.hh b/rl_env/include/rl_env/Arcade.hh
index e357ed6..3a40baa 100644
--- a/rl_env/include/rl_env/Arcade.hh
+++ b/rl_env/include/rl_env/Arcade.hh
@@ -36,8 +36,6 @@ public:
 
   virtual std::vector<experience> getSeedings();
 
-  long totalScore;
-
 protected:
   ALEInterface ale;
 	IntMatrix screen_matrix;
@@ -46,11 +44,8 @@ protected:
     char* romPath;
 	bool display_active;
 	bool game_over;
-  const int stateSpaceLength;
 	
 private:
   float minReward;
   float maxReward;
-  std::vector<float> state;
-  std::vector<ModelSpecification> modelSpecs;
 };
diff --git a/rl_env/src/Env/Arcade.cc b/rl_env/src/Env/Arcade.cc
index 1063163..0a6a526 100644
--- a/rl_env/src/Env/Arcade.cc
+++ b/rl_env/src/Env/Arcade.cc
@@ -9,6 +9,7 @@
 #include <cmath>
 
 char* Arcade::getEnvironmentDescription() {
+	// FIXME not correct information
     return 
         "Specialized environment for Asterix, "
         "uses 16 features:\n"
@@ -32,8 +33,8 @@ char* Arcade::getEnvironmentDescription() {
 }
 
 Arcade::Arcade(char* rom_path) :
-	totalScore(0), display_active(false), game_over(false), stateSpaceLength(16), state(stateSpaceLength),
-    modelSpecs(stateSpaceLength + 3)
+	Environment(16),
+	display_active(false), game_over(false)
 {
   // save the path
   romPath = rom_path;
diff --git a/rl_env/src/Env/FuelRooms.cc b/rl_env/src/Env/FuelRooms.cc
index cc149f5..0973c04 100755
--- a/rl_env/src/Env/FuelRooms.cc
+++ b/rl_env/src/Env/FuelRooms.cc
@@ -6,9 +6,10 @@
 */
 
 #include <rl_env/FuelRooms.hh>
-
+#define DEBUG_FUEL
 
 FuelRooms::FuelRooms(Random &rand, bool extraVariation, bool stoch):
+  Environment(16),
   height(20), width(30),
   goal(coord_t(11.0,24.0)), 
   extraVar(extraVariation),
@@ -20,6 +21,28 @@ FuelRooms::FuelRooms(Random &rand, bool extraVariation, bool stoch):
   energy(s[2])
 {
 
+  // set model types
+  // FIXME for texplore only
+  modelSpecs[0].modelType = C45TREE;
+  modelSpecs[1].modelType = CONSTANT;
+  modelSpecs[2].modelType = CONSTANT;
+  modelSpecs[3].modelType = CONSTANT;
+  modelSpecs[4].modelType = CONSTANT;
+  modelSpecs[5].modelType = CONSTANT;
+  modelSpecs[6].modelType = CONSTANT;
+  modelSpecs[7].modelType = CONSTANT;
+  modelSpecs[8].modelType = CONSTANT;
+  modelSpecs[9].modelType = C45TREE;
+  modelSpecs[10].modelType = C45TREE;
+  modelSpecs[11].modelType = C45TREE;
+  modelSpecs[12].modelType = C45TREE;
+  modelSpecs[13].modelType = CONSTANT;
+  modelSpecs[14].modelType = CONSTANT;
+  modelSpecs[15].modelType = CONSTANT;
+
+  modelSpecs[17].modelType = C45TREE; // reward
+  modelSpecs[18].modelType = C45TREE; // terminal
+
   fuelVisited = 0;
   totalVisited = 0;
 
@@ -52,18 +75,25 @@ float FuelRooms::apply(int action) {
   if (terminal())
     return 0.0;
 
-  //cout << "Taking action " << static_cast<room_action_t>(action) << endl;
+#ifdef DEBUG_FEUL
+  cout << "Taking action " << static_cast<room_action_t>(action) << endl;
 
-  //cout << "state: " << s[0] << ", " << s[1] << ", " << s[2] 
-  //    << " act: " << action << endl;
+  cout << "state: " << s[0] << ", " << s[1] << ", " << s[2]
+      << " act: " << action << endl;
+#endif
 
+  // ALTERNATIVE PLAN:
   // 20% lose none
   // 20% lose two
   // 80% of the time, lose one energy
   //  if (!noisy || rng.bernoulli(0.8))
+
+  // using static energy consumption
   energy--;
 
   // many fuel squares, with varying amounts reward
+
+  // fuel squares are at the north and south boundary.
   if ((int)ns == 0 || (int)ns == height){
     energy += 20.0;
   }
@@ -97,6 +127,7 @@ float FuelRooms::apply(int action) {
   
   return r;
   
+  // WHAT'S THIS?
   std::cerr << "Unreachable point reached in FuelRooms::apply!!!\n";
   return 0; // unreachable, I hope
 }
@@ -110,35 +141,33 @@ float FuelRooms::reward(int effect) {
   }
 
   if (terminal()){
-    //cout << "Found goal!!!!" << endl;
+#ifdef DEBUG_FUEL
+    cout << "Found goal!!!!" << endl;
+#endif
     return 0.0;
   }
 
-  // extra cost at fuel stations
-  /*
-  if (ns == 0 || ns == height){
-    return -5.0;
-  }
-  */
-
+  // cost from fuel station
   if (ns == 0 || ns == height){
+	// version 2
     float base = -10.0;
     if (ns == 0)
       base = -13.0;
-  
+
     // extra variation
-    float var = 1.0;
+    float var = 1.0; // version 1
     if (extraVar)
-      var = 5.0;
+      var = 5.0; // version 2
     else
-      base -= 8.0;
+      base -= 8.0; // version 1
 
     return base - (((int)ew % 5) * var);
-      
   }
- 
+
+  // cost for straight moving
   if (effect == NORTH || effect == SOUTH || effect == EAST || effect == WEST)
     return -1.0;
+  // cost for diagonal moving
   else
     return -1.4;
   
diff --git a/src/rl.cc b/src/rl.cc
index 80fcfdf..c8e4543 100755
--- a/src/rl.cc
+++ b/src/rl.cc
@@ -2,6 +2,8 @@
     \author Todd Hester
 */
 
+using namespace std;
+
 #include <rl_common/Random.h>
 #include <rl_common/core.hh>
 
@@ -44,10 +46,10 @@
 #include <getopt.h>
 #include <stdlib.h>
 
-unsigned NUMEPISODES = 300; //10; //200; //500; //200;
+unsigned NUMEPISODES = 30; //300; //200; //500; //200;
 const unsigned NUMTRIALS = 1; //30; //30; //5; //30; //30; //50
 unsigned MAXSTEPS = 2000; // per episode
-bool PRINTS = false;
+bool PRINTS = true; // will print helpful information
 
 
 void displayHelp(){
@@ -172,7 +174,6 @@ int main(int argc, char **argv) {
   }
 
   // parse env type
-  /*
   bool gotEnv = false;
   for (int i = 1; i < argc-1; i++){
     if (strcmp(argv[i], "--env") == 0){
@@ -181,10 +182,8 @@ int main(int argc, char **argv) {
     }
   }
   if (!gotEnv) {
-    cout << "--env type  option is required" << endl;
-    displayHelp();
+    cout << "--env type  not found. Assume Arcade." << endl;
   }
-  */
 
   // parse ROM path
   bool gotRom = false;
@@ -194,10 +193,6 @@ int main(int argc, char **argv) {
       romPath = argv[i+1];
     }
   }
-  if (!gotRom) {
-    cout << "--rom PATH required when env is arcade" << endl;
-    displayHelp();
-  }
 
   // parse other arguments
   char ch;
@@ -240,7 +235,8 @@ int main(int argc, char **argv) {
     {"nolag", 0, 0, 8},
     {"highvar", 0, 0, 11},
     {"nepisodes", 1, 0, 12},
-    {"rom", 1, 0, 13}
+    {"rom", 1, 0, 13},
+    {NULL, 0, 0, 0}
   };
 
   bool epsilonChanged = false;
@@ -689,10 +685,9 @@ int main(int argc, char **argv) {
   Random rng(1 + seed);
 
   // Construct environment here.
-  Arcade* e;
-  e = new Arcade(romPath);
+  Environment* e;
+  std::vector<int> statesPerDim;
 
-/*
   if (strcmp(envType, "cartpole") == 0){
     if (PRINTS) cout << "Environment: Cart Pole\n";
     e = new CartPole(rng, stochastic);
@@ -767,12 +762,16 @@ int main(int argc, char **argv) {
     e = new EnergyRooms(rng, stochastic, true, false);
   }
 
+  /* FIXME only enable fuelworld for current experiment.
+   * Other environments may have problems due to change of Environment structure.
+   */
   // gridworld with fuel (fuel stations on top and bottom with random costs)
   else if (strcmp(envType, "fuelworld") == 0){
     if (PRINTS) cout << "Environment: FuelWorld\n";
     e = new FuelRooms(rng, highvar, stochastic);
   }
 
+  /*
   // stocks
   else if (strcmp(envType, "stocks") == 0){
     if (PRINTS) cout << "Enironment: Stocks with " << nsectors
@@ -785,6 +784,16 @@ int main(int argc, char **argv) {
     exit(-1);
   }
 */
+  // assume Arcade if not matched above
+  else {
+	if (!gotRom) {
+	  cout << "--rom PATH required when env is arcade" << endl;
+	  displayHelp();
+	}
+	e = new Arcade(romPath);
+  }
+
+
   const int numactions = e->getNumActions(); // Most agents will need this?
 
   std::vector<float> minValues;
@@ -792,7 +801,6 @@ int main(int argc, char **argv) {
   e->getMinMaxFeatures(&minValues, &maxValues);
   bool episodic = e->isEpisodic();
   std::vector<ModelSpecification> modelSpecs = e->getModelSpecs();
-  std::vector<int> statesPerDim;
   e->getDiscretization(&statesPerDim);
 
   cout << "Environment is ";
@@ -830,9 +838,14 @@ int main(int argc, char **argv) {
     statesPerDim.resize(minValues.size(), nstates);
   }
 
+  /**
+   * Go through each trial
+   */
   for (unsigned j = 0; j < NUMTRIALS; ++j) {
 
-    // Construct agent here.
+    /**
+     *  Construct agent here.
+     */
     Agent* agent;
 
     if (strcmp(agentType, "qlearner") == 0){
@@ -867,6 +880,7 @@ int main(int argc, char **argv) {
                         rng);
     }
 
+    // rmax and texplore are also model based agents
     else if (strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") || strcmp(agentType, "texplore")){
       if (PRINTS) cout << "Agent: Model Based" << endl;
       agent = new ModelBasedAgent(numactions,
@@ -920,7 +934,9 @@ int main(int argc, char **argv) {
     // before we start, seed the agent with some experiences
     agent->seedExp(e->getSeedings());
 
-    // STEP BY STEP DOMAIN
+    /**
+     * Non-episodic domain
+     */
     if (!episodic){
 
       // performance tracking
@@ -967,7 +983,9 @@ int main(int argc, char **argv) {
 
     }
 
-    // EPISODIC DOMAINS
+    /**
+     * Episodic (like FuelRooms)
+     */
     else {
       ofstream scoreFile;
 
@@ -990,6 +1008,9 @@ int main(int argc, char **argv) {
       cerr << "REWARD: " << modelNames[modelSpecs[modelSpecs.size() - 2].modelType] << endl;
       cerr << "TERMINAL: " << modelNames[modelSpecs[modelSpecs.size() - 1].modelType] << endl << endl;
 
+      /**
+       * Pipe open other process and printing some stuff
+       */
       FILE *hostname = popen("hostname", "r");
       char hostbuffer[200];
       while (fgets(hostbuffer, sizeof(hostbuffer) - 1, hostname) != NULL) {
@@ -1014,9 +1035,9 @@ int main(int argc, char **argv) {
       cerr << endl << endl;
       cerr << "score\t#steps\t#invld" << endl;
 
-      //////////////////////////////////
-      // episodic
-      //////////////////////////////////
+      /**
+       * iterate over episodes
+       */
       for (unsigned i = 0; i < NUMEPISODES; ++i) {
 
         // performance tracking
@@ -1034,9 +1055,14 @@ int main(int argc, char **argv) {
         sum += r;
         ++steps;
 				
+        /**
+         * Take actions within one episode
+         */
         while (!e->terminal() && steps < MAXSTEPS) {
           // perform an action
           es = e->sensation();
+
+          // DUMMY. always return false.
           if (e->invalidStateChange(a)) {
               a = agent->next_action(r, lastValid);
               ++invalidStates;
@@ -1075,63 +1101,6 @@ int main(int argc, char **argv) {
 
   }
 
-  if (PRINTS) cout << "Avg Rsum: " << (rsum / (float)NUMTRIALS) << endl;
-
-} // end main
-				/*
-        while (!e->terminal() && steps < MAXSTEPS) {
-          printf("----------------------------------------------\n");
-
-          // perform an action
-          es = e->sensation();
-					
-          // (cdonahue) don't update learning while invalid
-          bool lostLoc = false;
-          while (e->lostLocation() && !e->terminal())
-          {
-              lostLoc = true;
-              r = e->apply(0);
-              //r = e->apply(1);
-              es = e->sensation();
-          }
-          if (lostLoc) {
-              a = agent->first_action(es);
-              if (e->terminal())
-                  break;
-              continue;
-          }
-
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-        }
-        */
-        /*
-        bool changedRow = false;
-        while (!e->terminal() && steps < MAXSTEPS) {
-
-          // perform an action
-          es = e->sensation();
-          if (changedRow) {
-              a = agent->first_action(es);
-              changedRow = false;
-          }
-          else {
-              a = agent->next_action(r, es);
-          }
-          r = e->apply(a);
-          if (a == 1 || a == 4) {
-              printf("CHANGED ROW");
-              changedRow = true;
-          }
-
-          // update performance info
-          sum += r;
-          ++steps;
-
-        }
-        */
+  if (PRINTS) cout << "Avg Rsum: " << (rsum / (float)NUMEPISODES / (float)NUMTRIALS) << endl;
 
+}
diff --git a/src/rl.invalidtreatedasfirst.cc b/src/rl.invalidtreatedasfirst.cc
deleted file mode 100755
index 1616504..0000000
--- a/src/rl.invalidtreatedasfirst.cc
+++ /dev/null
@@ -1,1130 +0,0 @@
-/** \file Main file that starts agents and environments
-    \author Todd Hester
-*/
-
-#include <rl_common/Random.h>
-#include <rl_common/core.hh>
-
-#include <stdio.h>
-#include <string.h>
-#include <sys/time.h>
-#include <iostream>
-#include <fstream>
-
-//////////////////
-// Environments //
-//////////////////
-#include <rl_env/Arcade.hh>
-#include <rl_env/RobotCarVel.hh>
-#include <rl_env/fourrooms.hh>
-#include <rl_env/tworooms.hh>
-#include <rl_env/taxi.hh>
-#include <rl_env/FuelRooms.hh>
-#include <rl_env/stocks.hh>
-#include <rl_env/energyrooms.hh>
-#include <rl_env/MountainCar.hh>
-#include <rl_env/CartPole.hh>
-#include <rl_env/LightWorld.hh>
-
-
-////////////
-// Agents //
-////////////
-#include <rl_agent/QLearner.hh>
-#include <rl_agent/ModelBasedAgent.hh>
-#include <rl_agent/DiscretizationAgent.hh>
-#include <rl_agent/SavedPolicy.hh>
-#include <rl_agent/Dyna.hh>
-#include <rl_agent/Sarsa.hh>
-
-#include <vector>
-#include <sstream>
-#include <iostream>
-
-#include <getopt.h>
-#include <stdlib.h>
-
-unsigned NUMEPISODES = 300; //10; //200; //500; //200;
-const unsigned NUMTRIALS = 1; //30; //30; //5; //30; //30; //50
-unsigned MAXSTEPS = 200; // per episode
-bool PRINTS = false;
-
-
-void displayHelp(){
-  cout << "\n Call experiment --agent type --env type [options]\n";
-  cout << "Agent types: qlearner sarsa modelbased rmax texplore dyna savedpolicy\n";
-  cout << "Env types: taxi tworooms fourrooms energy fuelworld mcar cartpole car2to7 car7to2 carrandom stocks lightworld\n";
-
-  cout << "\n Agent Options:\n";
-  cout << "--gamma value (discount factor between 0 and 1)\n";
-  cout << "--epsilon value (epsilon for epsilon-greedy exploration)\n";
-  cout << "--alpha value (learning rate alpha)\n";
-  cout << "--initialvalue value (initial q values)\n";
-  cout << "--actrate value (action selection rate (Hz))\n";
-  cout << "--lamba value (lamba for eligibility traces)\n";
-  cout << "--m value (parameter for R-Max)\n";
-  cout << "--k value (For Dyna: # of model based updates to do between each real world update)\n";
-  cout << "--history value (# steps of history to use for planning with delay)\n";
-  cout << "--filename file (file to load saved policy from for savedpolicy agent)\n";
-  cout << "--model type (tabular,tree,m5tree)\n";
-  cout << "--planner type (vi,pi,sweeping,uct,parallel-uct,delayed-uct,delayed-parallel-uct)\n";
-  cout << "--explore type (unknown,greedy,epsilongreedy,variancenovelty)\n";
-  cout << "--combo type (average,best,separate)\n";
-  cout << "--nmodels value (# of models)\n";
-  cout << "--nstates value (optionally discretize domain into value # of states on each feature)\n";
-  cout << "--reltrans (learn relative transitions)\n";
-  cout << "--abstrans (learn absolute transitions)\n";
-  cout << "--v value (For TEXPLORE: b/v coefficient for rewarding state-actions where models disagree)\n";
-  cout << "--n value (For TEXPLORE: n coefficient for rewarding state-actions which are novel)\n";
-
-  cout << "\n Env Options:\n";
-  cout << "--deterministic (deterministic version of domain)\n";
-  cout << "--stochastic (stochastic version of domain)\n";
-  cout << "--delay value (# steps of action delay (for mcar and tworooms)\n";
-  cout << "--lag (turn on brake lag for car driving domain)\n";
-  cout << "--highvar (have variation fuel costs in Fuel World)\n";
-  cout << "--nsectors value (# sectors for stocks domain)\n";
-  cout << "--nstocks value (# stocks for stocks domain)\n";
-  cout << "--rom path (path to ROM for Arcade env)\n";
-
-  cout << "\n--prints (turn on debug printing of actions/rewards)\n";
-  cout << "--nepisodes value (# of episodes to run (1000 default)\n";
-  cout << "--seed value (integer seed for random number generator)\n";
-
-  cout << "\n For more info, see: http://www.ros.org/wiki/rl_experiment\n";
-
-  exit(-1);
-
-}
-
-
-int main(int argc, char **argv) {
-
-  // default params for env and agent
-  char* agentType = NULL;
-  char* envType = NULL;
-  char* romPath = NULL;
-  char* modelTypeString = NULL;
-  float discountfactor = 0.99;
-  float epsilon = 0.1;
-  float alpha = 0.3;
-  float initialvalue = 0.0;
-  float actrate = 10.0;
-  float lambda = 0.1;
-  int M = 5;
-  int modelType = C45TREE;
-  int exploreType = GREEDY;
-  int predType = BEST;
-  int plannerType = PAR_ETUCT_ACTUAL;
-  int nmodels = 1;
-  bool reltrans = true;
-  bool deptrans = false;
-  float v = 0;
-  float n = 0;
-  float featPct = 0.2;
-  int nstates = 0;
-  int k = 1000;
-  char *filename = NULL;
-  bool stochastic = true;
-  int nstocks = 3;
-  int nsectors = 3;
-  int delay = 0;
-  bool lag = false;
-  bool highvar = false;
-  int history = 0;
-  int seed = 1;
-  // change some of these parameters based on command line args
-
-  // parse agent type
-  bool gotAgent = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--agent") == 0){
-      gotAgent = true;
-      agentType = argv[i+1];
-    }
-  }
-  if (!gotAgent) {
-    cout << "--agent type  option is required" << endl;
-    displayHelp();
-  }
-
-  // set some default options for rmax or texplore
-  if (strcmp(agentType, "rmax") == 0){
-    modelType = RMAX;
-    exploreType = EXPLORE_UNKNOWN;
-    predType = BEST;
-    plannerType = VALUE_ITERATION;
-    nmodels = 1;
-    reltrans = false;
-    M = 5;
-    history = 0;
-  } else if (strcmp(agentType, "texplore") == 0){
-    modelType = C45TREE;
-    exploreType = DIFF_AND_NOVEL_BONUS;
-    v = 0;
-    n = 0;
-    predType = AVERAGE;
-    plannerType = PAR_ETUCT_ACTUAL;
-    nmodels = 5;
-    reltrans = true;
-    M = 0;
-    history = 0;
-  }
-
-  // parse env type
-  /*
-  bool gotEnv = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--env") == 0){
-      gotEnv = true;
-      envType = argv[i+1];
-    }
-  }
-  if (!gotEnv) {
-    cout << "--env type  option is required" << endl;
-    displayHelp();
-  }
-  */
-
-  // parse ROM path
-  bool gotRom = false;
-  for (int i = 1; i < argc-1; i++) {
-    if (strcmp(argv[i], "--rom") == 0){
-      gotRom = true;
-      romPath = argv[i+1];
-    }
-  }
-  if (!gotRom) {
-    cout << "--rom PATH required when env is arcade" << endl;
-    displayHelp();
-  }
-
-  // parse other arguments
-  char ch;
-  const char* optflags = "geairlmoxpcn:";
-  int option_index = 0;
-  static struct option long_options[] = {
-    {"gamma", 1, 0, 'g'},
-    {"discountfactor", 1, 0, 'g'},
-    {"epsilon", 1, 0, 'e'},
-    {"alpha", 1, 0, 'a'},
-    {"initialvalue", 1, 0, 'i'},
-    {"actrate", 1, 0, 'r'},
-    {"lambda", 1, 0, 'l'},
-    {"m", 1, 0, 'm'},
-    {"model", 1, 0, 'o'},
-    {"explore", 1, 0, 'x'},
-    {"planner", 1, 0, 'p'},
-    {"combo", 1, 0, 'c'},
-    {"nmodels", 1, 0, '#'},
-    {"reltrans", 0, 0, 't'},
-    {"abstrans", 0, 0, '0'},
-    {"seed", 1, 0, 's'},
-    {"agent", 1, 0, 'q'},
-    {"prints", 0, 0, 'd'},
-    {"nstates", 1, 0, 'w'},
-    {"k", 1, 0, 'k'},
-    {"filename", 1, 0, 'f'},
-    {"history", 1, 0, 'y'},
-    {"b", 1, 0, 'b'},
-    {"v", 1, 0, 'v'},
-    {"n", 1, 0, 'n'},
-
-    {"env", 1, 0, 1},
-    {"deterministic", 0, 0, 2},
-    {"stochastic", 0, 0, 3},
-    {"delay", 1, 0, 4},
-    {"nsectors", 1, 0, 5},
-    {"nstocks", 1, 0, 6},
-    {"lag", 0, 0, 7},
-    {"nolag", 0, 0, 8},
-    {"highvar", 0, 0, 11},
-    {"nepisodes", 1, 0, 12},
-    {"rom", 1, 0, 13}
-  };
-
-  bool epsilonChanged = false;
-  bool actrateChanged = false;
-  bool mChanged = false;
-  bool bvnChanged = false;
-  bool lambdaChanged = false;
-
-  while(-1 != (ch = getopt_long_only(argc, argv, optflags, long_options, &option_index))) {
-    switch(ch) {
-
-    case 'g':
-      discountfactor = std::atof(optarg);
-      cout << "discountfactor: " << discountfactor << endl;
-      break;
-
-    case 'e':
-      epsilonChanged = true;
-      epsilon = std::atof(optarg);
-      cout << "epsilon: " << epsilon << endl;
-      break;
-
-    case 'y':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          history = std::atoi(optarg);
-          cout << "history: " << history << endl;
-        } else {
-          cout << "--history is not a valid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'k':
-      {
-        if (strcmp(agentType, "dyna") == 0){
-          k = std::atoi(optarg);
-          cout << "k: " << k << endl;
-        } else {
-          cout << "--k is only a valid option for the Dyna agent" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'f':
-      filename = optarg;
-      cout << "policy filename: " <<  filename << endl;
-      break;
-
-    case 'a':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          alpha = std::atof(optarg);
-          cout << "alpha: " << alpha << endl;
-        } else {
-          cout << "--alpha option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'i':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          initialvalue = std::atof(optarg);
-          cout << "initialvalue: " << initialvalue << endl;
-        } else {
-          cout << "--initialvalue option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'r':
-      {
-        actrateChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          actrate = std::atof(optarg);
-          cout << "actrate: " << actrate << endl;
-        } else {
-          cout << "Model-free methods do not require an action rate" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'l':
-      {
-        lambdaChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0 || strcmp(agentType, "sarsa") == 0){
-          lambda = std::atof(optarg);
-          cout << "lambda: " << lambda << endl;
-        } else {
-          cout << "--lambda option is invalid for this agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'm':
-      {
-        mChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          M = std::atoi(optarg);
-          cout << "M: " << M << endl;
-        } else {
-          cout << "--M option only useful for model-based agents, not " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'o':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          if (strcmp(optarg, "tabular") == 0) modelType = RMAX;
-          else if (strcmp(optarg, "tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "texplore") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "c45tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "m5tree") == 0) modelType = M5ALLMULTI;
-          if (strcmp(agentType, "rmax") == 0 && modelType != RMAX){
-            cout << "R-Max should use tabular model" << endl;
-            exit(-1);
-          }
-        } else {
-          cout << "Model-free methods do not need a model, --model option does nothing for this agent type" << endl;
-          exit(-1);
-        }
-        cout << "model: " << modelNames[modelType] << endl;
-        break;
-      }
-
-    case 'x':
-      {
-        if (strcmp(optarg, "unknown") == 0) exploreType = EXPLORE_UNKNOWN;
-        else if (strcmp(optarg, "greedy") == 0) exploreType = GREEDY;
-        else if (strcmp(optarg, "epsilongreedy") == 0) exploreType = EPSILONGREEDY;
-        else if (strcmp(optarg, "unvisitedstates") == 0) exploreType = UNVISITED_BONUS;
-        else if (strcmp(optarg, "unvisitedactions") == 0) exploreType = UNVISITED_ACT_BONUS;
-        else if (strcmp(optarg, "variancenovelty") == 0) exploreType = DIFF_AND_NOVEL_BONUS;
-        if (strcmp(agentType, "rmax") == 0 && exploreType != EXPLORE_UNKNOWN){
-          cout << "R-Max should use \"--explore unknown\" exploration" << endl;
-          exit(-1);
-        }
-        else if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0 && (exploreType != GREEDY && exploreType != EPSILONGREEDY)) {
-          cout << "Model free methods must use either greedy or epsilon-greedy exploration!" << endl;
-          exploreType = EPSILONGREEDY;
-          exit(-1);
-        }
-        cout << "explore: " << exploreNames[exploreType] << endl;
-        break;
-      }
-
-    case 'p':
-      {
-        if (strcmp(optarg, "vi") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "valueiteration") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "policyiteration") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "pi") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "sweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "prioritizedsweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "uct") == 0) plannerType = ET_UCT_ACTUAL;
-        else if (strcmp(optarg, "paralleluct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtimeuct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtime-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "parallel-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "delayeduct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayed-uct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayedparalleluct") == 0) plannerType = POMDP_PAR_ETUCT;
-        else if (strcmp(optarg, "delayed-parallel-uct") == 0) plannerType = POMDP_PAR_ETUCT;
-        if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0){
-          cout << "Model-free methods do not require planners, --planner option does nothing with this agent" << endl;
-          exit(-1);
-        }
-        if (strcmp(agentType, "rmax") == 0 && plannerType != VALUE_ITERATION){
-          cout << "Typical implementation of R-Max would use value iteration, but another planner type is ok" << endl;
-        }
-        cout << "planner: " << plannerNames[plannerType] << endl;
-        break;
-      }
-
-    case 'c':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          if (strcmp(optarg, "average") == 0) predType = AVERAGE;
-          else if (strcmp(optarg, "weighted") == 0) predType = WEIGHTAVG;
-          else if (strcmp(optarg, "best") == 0) predType = BEST;
-          else if (strcmp(optarg, "separate") == 0) predType = SEPARATE;
-          cout << "predType: " << comboNames[predType] << endl;
-        } else {
-          cout << "--combo is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '#':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          nmodels = std::atoi(optarg);
-          cout << "nmodels: " << nmodels << endl;
-        } else {
-          cout << "--nmodels is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        if (nmodels < 1){
-          cout << "nmodels must be > 0" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 't':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = true;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--reltrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '0':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = false;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--abstrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 's':
-      seed = std::atoi(optarg);
-      cout << "seed: " << seed << endl;
-      break;
-
-    case 'q':
-      // already processed this one
-      cout << "agent: " << agentType << endl;
-      break;
-
-    case 'd':
-      PRINTS = true;
-      break;
-
-    case 'w':
-      nstates = std::atoi(optarg);
-      cout << "nstates for discretization: " << nstates << endl;
-      break;
-
-    case 'v':
-    case 'b':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          v = std::atof(optarg);
-          cout << "v coefficient (variance bonus): " << v << endl;
-        }
-        else {
-          cout << "--v and --b are invalid options for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'n':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          n = std::atof(optarg);
-          cout << "n coefficient (novelty bonus): " << n << endl;
-        }
-        else {
-          cout << "--n is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 2:
-      stochastic = false;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 11:
-      {
-        if (strcmp(envType, "fuelworld") == 0){
-          highvar = true;
-          cout << "fuel world fuel cost variation: " << highvar << endl;
-        } else {
-          cout << "--highvar is only a valid option for the fuelworld domain." << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 3:
-      stochastic = true;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 4:
-      {
-        if (strcmp(envType, "mcar") == 0 || strcmp(envType, "tworooms") == 0){
-          delay = std::atoi(optarg);
-          cout << "delay steps: " << delay << endl;
-        } else {
-          cout << "--delay option is only valid for the mcar and tworooms domains" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 5:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nsectors = std::atoi(optarg);
-          cout << "nsectors: " << nsectors << endl;
-        } else {
-          cout << "--nsectors option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 6:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nstocks = std::atoi(optarg);
-          cout << "nstocks: " << nstocks << endl;
-        } else {
-          cout << "--nstocks option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 7:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = true;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--lag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 8:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = false;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--nolag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 1:
-      // already processed this one
-      cout << "env: " << envType << endl;
-      break;
-
-    case 12:
-      NUMEPISODES = std::atoi(optarg);
-      cout << "Num Episodes: " << NUMEPISODES << endl;
-      break;
-
-    case 13:
-      // rom case, already processed
-      break;
-
-    case 'h':
-    case '?':
-    case 0:
-    default:
-      displayHelp();
-      break;
-    }
-  }
-
-  // default back to greedy if no coefficients
-  if (exploreType == DIFF_AND_NOVEL_BONUS && v == 0 && n == 0)
-    exploreType = GREEDY;
-
-  // check for conflicting options
-  // changed epsilon but not doing epsilon greedy exploration
-  if (epsilonChanged && exploreType != EPSILONGREEDY){
-    cout << "No reason to change epsilon when not using epsilon-greedy exploration" << endl;
-    exit(-1);
-  }
-
-  // set history value but not doing uct w/history planner
-  if (history > 0 && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set history higher than 0 if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set action rate but not doing real-time planner
-  if (actrateChanged && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set lambda but not doing uct (lambda)
-  if (lambdaChanged && (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0) && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set n/v/b but not doing that diff_novel exploration
-  if (bvnChanged && exploreType != DIFF_AND_NOVEL_BONUS){
-    cout << "No reason to set n or v if not doing variance & novelty exploration" << endl;
-    exit(-1);
-  }
-
-  // set combo other than best but only doing 1 model
-  if (predType != BEST && nmodels == 1){
-    cout << "No reason to have model combo other than best with nmodels = 1" << endl;
-    exit(-1);
-  }
-
-  // set M but not doing explore unknown
-  if (mChanged && exploreType != EXPLORE_UNKNOWN){
-    cout << "No reason to set M if not doing R-max style Explore Unknown exploration" << endl;
-    exit(-1);
-  }
-
-  if (PRINTS){
-    if (stochastic)
-      cout << "Stohastic\n";
-    else
-      cout << "Deterministic\n";
-  }
-
-  Random rng(1 + seed);
-
-  // Construct environment here.
-  Arcade* e;
-  e = new Arcade(romPath);
-
-/*
-  if (strcmp(envType, "cartpole") == 0){
-    if (PRINTS) cout << "Environment: Cart Pole\n";
-    e = new CartPole(rng, stochastic);
-  }
-
-  else if (strcmp(envType, "mcar") == 0){
-    if (PRINTS) cout << "Environment: Mountain Car\n";
-    e = new MountainCar(rng, stochastic, false, delay);
-  }
-
-  // taxi
-  else if (strcmp(envType, "taxi") == 0){
-    if (PRINTS) cout << "Environment: Taxi\n";
-    e = new Taxi(rng, stochastic);
-  }
-
-  // Light World
-  else if (strcmp(envType, "lightworld") == 0){
-    if (PRINTS) cout << "Environment: Light World\n";
-    e = new LightWorld(rng, stochastic, 4);
-  }
-
-  // two rooms
-  else if (strcmp(envType, "tworooms") == 0){
-    if (PRINTS) cout << "Environment: TwoRooms\n";
-    e = new TwoRooms(rng, stochastic, true, delay, false);
-  }
-
-  // car vel, 2 to 7
-  else if (strcmp(envType, "car2to7") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 2 to 7 m/s\n";
-    e = new RobotCarVel(rng, false, true, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, 7 to 2
-  else if (strcmp(envType, "car7to2") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 7 to 2 m/s\n";
-    e = new RobotCarVel(rng, false, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, random vels
-  else if (strcmp(envType, "carrandom") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity Random Velocities\n";
-    e = new RobotCarVel(rng, true, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 48;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-
-  // four rooms
-  else if (strcmp(envType, "fourrooms") == 0){
-    if (PRINTS) cout << "Environment: FourRooms\n";
-    e = new FourRooms(rng, stochastic, true, false);
-  }
-
-  // four rooms with energy level
-  else if (strcmp(envType, "energy") == 0){
-    if (PRINTS) cout << "Environment: EnergyRooms\n";
-    e = new EnergyRooms(rng, stochastic, true, false);
-  }
-
-  // gridworld with fuel (fuel stations on top and bottom with random costs)
-  else if (strcmp(envType, "fuelworld") == 0){
-    if (PRINTS) cout << "Environment: FuelWorld\n";
-    e = new FuelRooms(rng, highvar, stochastic);
-  }
-
-  // stocks
-  else if (strcmp(envType, "stocks") == 0){
-    if (PRINTS) cout << "Enironment: Stocks with " << nsectors
-                     << " sectors and " << nstocks << " stocks\n";
-    e = new Stocks(rng, stochastic, nsectors, nstocks);
-  }
-
-  else {
-    std::cerr << "Invalid env type" << endl;
-    exit(-1);
-  }
-*/
-  const int numactions = e->getNumActions(); // Most agents will need this?
-
-  std::vector<float> minValues;
-  std::vector<float> maxValues;
-  e->getMinMaxFeatures(&minValues, &maxValues);
-  bool episodic = e->isEpisodic();
-  std::vector<ModelSpecification> modelSpecs = e->getModelSpecs();
-  std::vector<int> statesPerDim;
-  e->getDiscretization(&statesPerDim);
-
-  cout << "Environment is ";
-  if (!episodic) cout << "NOT ";
-  cout << "episodic." << endl;
-
-  // lets just check this for now
-  for (unsigned i = 0; i < minValues.size(); i++){
-    if (PRINTS) cout << "Feat " << i << " min: " << minValues[i]
-                     << " max: " << maxValues[i] << endl;
-  }
-
-  // get max/min reward for the domain
-  float rMax = 0.0;
-  float rMin = -1.0;
-
-  e->getMinMaxReward(&rMin, &rMax);
-  float rRange = rMax - rMin;
-  if (PRINTS) cout << "Min Reward: " << rMin
-                   << ", Max Reward: " << rMax << endl;
-
-  // set rmax as a bonus for certain exploration types
-  if (rMax <= 0.0 && (exploreType == TWO_MODE_PLUS_R ||
-                      exploreType == CONTINUOUS_BONUS_R ||
-                      exploreType == CONTINUOUS_BONUS ||
-                      exploreType == THRESHOLD_BONUS_R)){
-    rMax = 1.0;
-  }
-
-
-  float rsum = 0;
-
-  if (statesPerDim.size() == 0){
-    cout << "set statesPerDim to " << nstates << " for all dim" << endl;
-    statesPerDim.resize(minValues.size(), nstates);
-  }
-
-  for (unsigned j = 0; j < NUMTRIALS; ++j) {
-
-    // Construct agent here.
-    Agent* agent;
-
-    if (strcmp(agentType, "qlearner") == 0){
-      if (PRINTS) cout << "Agent: QLearner" << endl;
-      agent = new QLearner(numactions,
-                           discountfactor,
-                           initialvalue, //0.0, // initialvalue
-                           alpha, // alpha
-                           epsilon, // epsilon
-                           rng);
-    }
-
-    else if (strcmp(agentType, "dyna") == 0){
-      if (PRINTS) cout << "Agent: Dyna" << endl;
-      agent = new Dyna(numactions,
-                       discountfactor,
-                       initialvalue, //0.0, // initialvalue
-                       alpha, // alpha
-                       k, // k
-                       epsilon, // epsilon
-                       rng);
-    }
-
-    else if (strcmp(agentType, "sarsa") == 0){
-      if (PRINTS) cout << "Agent: SARSA" << endl;
-      agent = new Sarsa(numactions,
-                        discountfactor,
-                        initialvalue, //0.0, // initialvalue
-                        alpha, // alpha
-                        epsilon, // epsilon
-                        lambda,
-                        rng);
-    }
-
-    else if (strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") || strcmp(agentType, "texplore")){
-      if (PRINTS) cout << "Agent: Model Based" << endl;
-      agent = new ModelBasedAgent(numactions,
-                                  discountfactor,
-                                  rMax, rRange,
-                                  modelType,
-                                  exploreType,
-                                  predType,
-                                  nmodels,
-                                  plannerType,
-                                  epsilon, // epsilon
-                                  lambda,
-                                  (1.0/actrate), //0.1, //0.1, //0.01, // max time
-                                  M,
-                                  minValues, maxValues, modelSpecs,
-                                  statesPerDim,//0,
-                                  history, v, n,
-                                  deptrans, reltrans, featPct, stochastic, episodic,
-                                  rng);
-    }
-
-    else if (strcmp(agentType, "savedpolicy") == 0){
-      if (PRINTS) cout << "Agent: Saved Policy" << endl;
-      agent = new SavedPolicy(numactions,filename);
-    }
-
-    else {
-      std::cerr << "ERROR: Invalid agent type" << endl;
-      exit(-1);
-    }
-
-    // start discrete agent if we're discretizing (if nstates > 0 and not agent type 'c')
-    int totalStates = 1;
-    Agent* a2 = agent;
-    // not for model based when doing continuous model
-    if (nstates > 0 && (modelType != M5ALLMULTI || strcmp(agentType, "qlearner") == 0)){
-      int totalStates = powf(nstates,minValues.size());
-      if (PRINTS) cout << "Discretize with " << nstates << ", total: " << totalStates << endl;
-      agent = new DiscretizationAgent(nstates, a2,
-                                      minValues, maxValues, PRINTS);
-    }
-    else {
-      totalStates = 1;
-      for (unsigned i = 0; i < minValues.size(); i++){
-        int range = 1+maxValues[i] - minValues[i];
-        totalStates *= range;
-      }
-      if (PRINTS) cout << "No discretization, total: " << totalStates << endl;
-    }
-
-    // before we start, seed the agent with some experiences
-    agent->seedExp(e->getSeedings());
-
-    // STEP BY STEP DOMAIN
-    if (!episodic){
-
-      // performance tracking
-      float sum = 0;
-      int steps = 0;
-      float trialSum = 0.0;
-
-      int a = 0;
-      float r = 0;
-
-      //////////////////////////////////
-      // non-episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i){
-
-        std::vector<float> es = e->sensation();
-
-        // first step
-        if (i == 0){
-
-          // first action
-          a = agent->first_action(es);
-          r = e->apply(a);
-
-        } else {
-          // next action
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-        }
-
-        // update performance
-        sum += r;
-        ++steps;
-
-        std::cerr << r << endl;
-
-      }
-      ///////////////////////////////////
-
-      rsum += sum;
-      trialSum += sum;
-      if (PRINTS) cout << "Rsum(trial " << j << "): " << trialSum << " Avg: "
-                       << (rsum / (float)(j+1))<< endl;
-
-    }
-
-    // EPISODIC DOMAINS
-    else {
-      ofstream scoreFile;
-
-      time_t now = time(0);
-      struct tm tstruct;
-      char buff[80];
-      tstruct = *localtime(&now);
-      strftime(buff, sizeof(buff), "%m.%d.%Y\n%H.%M.%S\n", &tstruct);
-      
-      cerr << buff;
-
-      for (unsigned i = 0; i < argc; i++) {
-          cerr << argv[i] << " ";
-      }
-      cerr << endl << endl;
-      cerr << e->getEnvironmentDescription();
-      for (unsigned i = 0; i < modelSpecs.size() - 3; i++) {
-          cerr << i << ": " << modelNames[modelSpecs[i].modelType] << endl;
-      }
-      cerr << "REWARD: " << modelNames[modelSpecs[modelSpecs.size() - 2].modelType] << endl;
-      cerr << "TERMINAL: " << modelNames[modelSpecs[modelSpecs.size() - 1].modelType] << endl << endl;
-
-      FILE *hostname = popen("hostname", "r");
-      char hostbuffer[200];
-      while (fgets(hostbuffer, sizeof(hostbuffer) - 1, hostname) != NULL) {
-          cerr << hostbuffer;
-      }
-      pclose(hostname);
-
-      FILE *lscpu = popen("lscpu", "r");
-      char lscpubuffer[1024];
-      while (fgets(lscpubuffer, sizeof(lscpubuffer) - 1, lscpu) != NULL) {
-          cerr << lscpubuffer;
-      }
-      pclose(lscpu);
-
-      FILE *meminfo = popen("grep \"Mem\" /proc/meminfo", "r");
-      char meminfobuffer[200];
-      while (fgets(meminfobuffer, sizeof(meminfobuffer) - 1, meminfo) != NULL) {
-          cerr << meminfobuffer;
-      }
-      pclose(meminfo);
-
-      cerr << endl << endl;
-      cerr << "score\t#steps\t#invld" << endl;
-
-      //////////////////////////////////
-      // episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i) {
-
-        // performance tracking
-        float sum = 0;
-        int steps = 0;
-        int invalidStates = 0;
-
-        // first action
-        std::vector<float> es = e->sensation();
-        int a = agent->first_action(es);
-        float r = e->apply(a);
-
-        // update performance
-        sum += r;
-        ++steps;
-				
-        while (!e->terminal() && steps < MAXSTEPS) {
-          // perform an action
-          es = e->sensation();
-          if (e->invalidStateChange(a)) {
-              a = agent->first_action(es);
-              ++invalidStates;
-          }
-          else {
-              a = agent->next_action(r, es);
-          }
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-        }
- 
-        // terminal/last state
-        if (e->terminal()){
-          agent->last_action(r);
-        }else{
-          agent->next_action(r, e->sensation());
-        }
-
-        cerr << e->totalScore << "\t" << steps << "\t" << invalidStates << endl;
-        e->reset();
-        //std::cerr << sum << endl;
-        rsum += sum;
-      } 
-    }
-
-    if (NUMTRIALS > 1) delete agent;
-
-  }
-
-  if (PRINTS) cout << "Avg Rsum: " << (rsum / (float)NUMTRIALS) << endl;
-
-} // end main
-				/*
-        while (!e->terminal() && steps < MAXSTEPS) {
-          printf("----------------------------------------------\n");
-
-          // perform an action
-          es = e->sensation();
-					
-          // (cdonahue) don't update learning while invalid
-          bool lostLoc = false;
-          while (e->lostLocation() && !e->terminal())
-          {
-              lostLoc = true;
-              r = e->apply(0);
-              //r = e->apply(1);
-              es = e->sensation();
-          }
-          if (lostLoc) {
-              a = agent->first_action(es);
-              if (e->terminal())
-                  break;
-              continue;
-          }
-
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-        }
-        */
-        /*
-        bool changedRow = false;
-        while (!e->terminal() && steps < MAXSTEPS) {
-
-          // perform an action
-          es = e->sensation();
-          if (changedRow) {
-              a = agent->first_action(es);
-              changedRow = false;
-          }
-          else {
-              a = agent->next_action(r, es);
-          }
-          r = e->apply(a);
-          if (a == 1 || a == 4) {
-              printf("CHANGED ROW");
-              changedRow = true;
-          }
-
-          // update performance info
-          sum += r;
-          ++steps;
-
-        }
-        */
-
diff --git a/src/rl.noinvalidallowed.cc b/src/rl.noinvalidallowed.cc
deleted file mode 100755
index 80fcfdf..0000000
--- a/src/rl.noinvalidallowed.cc
+++ /dev/null
@@ -1,1137 +0,0 @@
-/** \file Main file that starts agents and environments
-    \author Todd Hester
-*/
-
-#include <rl_common/Random.h>
-#include <rl_common/core.hh>
-
-#include <stdio.h>
-#include <string.h>
-#include <sys/time.h>
-#include <iostream>
-#include <fstream>
-
-//////////////////
-// Environments //
-//////////////////
-#include <rl_env/Arcade.hh>
-#include <rl_env/RobotCarVel.hh>
-#include <rl_env/fourrooms.hh>
-#include <rl_env/tworooms.hh>
-#include <rl_env/taxi.hh>
-#include <rl_env/FuelRooms.hh>
-#include <rl_env/stocks.hh>
-#include <rl_env/energyrooms.hh>
-#include <rl_env/MountainCar.hh>
-#include <rl_env/CartPole.hh>
-#include <rl_env/LightWorld.hh>
-
-
-////////////
-// Agents //
-////////////
-#include <rl_agent/QLearner.hh>
-#include <rl_agent/ModelBasedAgent.hh>
-#include <rl_agent/DiscretizationAgent.hh>
-#include <rl_agent/SavedPolicy.hh>
-#include <rl_agent/Dyna.hh>
-#include <rl_agent/Sarsa.hh>
-
-#include <vector>
-#include <sstream>
-#include <iostream>
-
-#include <getopt.h>
-#include <stdlib.h>
-
-unsigned NUMEPISODES = 300; //10; //200; //500; //200;
-const unsigned NUMTRIALS = 1; //30; //30; //5; //30; //30; //50
-unsigned MAXSTEPS = 2000; // per episode
-bool PRINTS = false;
-
-
-void displayHelp(){
-  cout << "\n Call experiment --agent type --env type [options]\n";
-  cout << "Agent types: qlearner sarsa modelbased rmax texplore dyna savedpolicy\n";
-  cout << "Env types: taxi tworooms fourrooms energy fuelworld mcar cartpole car2to7 car7to2 carrandom stocks lightworld\n";
-
-  cout << "\n Agent Options:\n";
-  cout << "--gamma value (discount factor between 0 and 1)\n";
-  cout << "--epsilon value (epsilon for epsilon-greedy exploration)\n";
-  cout << "--alpha value (learning rate alpha)\n";
-  cout << "--initialvalue value (initial q values)\n";
-  cout << "--actrate value (action selection rate (Hz))\n";
-  cout << "--lamba value (lamba for eligibility traces)\n";
-  cout << "--m value (parameter for R-Max)\n";
-  cout << "--k value (For Dyna: # of model based updates to do between each real world update)\n";
-  cout << "--history value (# steps of history to use for planning with delay)\n";
-  cout << "--filename file (file to load saved policy from for savedpolicy agent)\n";
-  cout << "--model type (tabular,tree,m5tree)\n";
-  cout << "--planner type (vi,pi,sweeping,uct,parallel-uct,delayed-uct,delayed-parallel-uct)\n";
-  cout << "--explore type (unknown,greedy,epsilongreedy,variancenovelty)\n";
-  cout << "--combo type (average,best,separate)\n";
-  cout << "--nmodels value (# of models)\n";
-  cout << "--nstates value (optionally discretize domain into value # of states on each feature)\n";
-  cout << "--reltrans (learn relative transitions)\n";
-  cout << "--abstrans (learn absolute transitions)\n";
-  cout << "--v value (For TEXPLORE: b/v coefficient for rewarding state-actions where models disagree)\n";
-  cout << "--n value (For TEXPLORE: n coefficient for rewarding state-actions which are novel)\n";
-
-  cout << "\n Env Options:\n";
-  cout << "--deterministic (deterministic version of domain)\n";
-  cout << "--stochastic (stochastic version of domain)\n";
-  cout << "--delay value (# steps of action delay (for mcar and tworooms)\n";
-  cout << "--lag (turn on brake lag for car driving domain)\n";
-  cout << "--highvar (have variation fuel costs in Fuel World)\n";
-  cout << "--nsectors value (# sectors for stocks domain)\n";
-  cout << "--nstocks value (# stocks for stocks domain)\n";
-  cout << "--rom path (path to ROM for Arcade env)\n";
-
-  cout << "\n--prints (turn on debug printing of actions/rewards)\n";
-  cout << "--nepisodes value (# of episodes to run (1000 default)\n";
-  cout << "--seed value (integer seed for random number generator)\n";
-
-  cout << "\n For more info, see: http://www.ros.org/wiki/rl_experiment\n";
-
-  exit(-1);
-
-}
-
-
-int main(int argc, char **argv) {
-
-  // default params for env and agent
-  char* agentType = NULL;
-  char* envType = NULL;
-  char* romPath = NULL;
-  char* modelTypeString = NULL;
-  float discountfactor = 0.99;
-  float epsilon = 0.1;
-  float alpha = 0.3;
-  float initialvalue = 0.0;
-  float actrate = 10.0;
-  float lambda = 0.1;
-  int M = 5;
-  int modelType = C45TREE;
-  int exploreType = GREEDY;
-  int predType = BEST;
-  int plannerType = PAR_ETUCT_ACTUAL;
-  int nmodels = 1;
-  bool reltrans = true;
-  bool deptrans = false;
-  float v = 0;
-  float n = 0;
-  float featPct = 0.2;
-  int nstates = 0;
-  int k = 1000;
-  char *filename = NULL;
-  bool stochastic = true;
-  int nstocks = 3;
-  int nsectors = 3;
-  int delay = 0;
-  bool lag = false;
-  bool highvar = false;
-  int history = 0;
-  int seed = 1;
-  // change some of these parameters based on command line args
-
-  // parse agent type
-  bool gotAgent = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--agent") == 0){
-      gotAgent = true;
-      agentType = argv[i+1];
-    }
-  }
-  if (!gotAgent) {
-    cout << "--agent type  option is required" << endl;
-    displayHelp();
-  }
-
-  // set some default options for rmax or texplore
-  if (strcmp(agentType, "rmax") == 0){
-    modelType = RMAX;
-    exploreType = EXPLORE_UNKNOWN;
-    predType = BEST;
-    plannerType = VALUE_ITERATION;
-    nmodels = 1;
-    reltrans = false;
-    M = 5;
-    history = 0;
-  } else if (strcmp(agentType, "texplore") == 0){
-    modelType = C45TREE;
-    exploreType = DIFF_AND_NOVEL_BONUS;
-    v = 0;
-    n = 0;
-    predType = AVERAGE;
-    plannerType = PAR_ETUCT_ACTUAL;
-    nmodels = 5;
-    reltrans = true;
-    M = 0;
-    history = 0;
-  }
-
-  // parse env type
-  /*
-  bool gotEnv = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--env") == 0){
-      gotEnv = true;
-      envType = argv[i+1];
-    }
-  }
-  if (!gotEnv) {
-    cout << "--env type  option is required" << endl;
-    displayHelp();
-  }
-  */
-
-  // parse ROM path
-  bool gotRom = false;
-  for (int i = 1; i < argc-1; i++) {
-    if (strcmp(argv[i], "--rom") == 0){
-      gotRom = true;
-      romPath = argv[i+1];
-    }
-  }
-  if (!gotRom) {
-    cout << "--rom PATH required when env is arcade" << endl;
-    displayHelp();
-  }
-
-  // parse other arguments
-  char ch;
-  const char* optflags = "geairlmoxpcn:";
-  int option_index = 0;
-  static struct option long_options[] = {
-    {"gamma", 1, 0, 'g'},
-    {"discountfactor", 1, 0, 'g'},
-    {"epsilon", 1, 0, 'e'},
-    {"alpha", 1, 0, 'a'},
-    {"initialvalue", 1, 0, 'i'},
-    {"actrate", 1, 0, 'r'},
-    {"lambda", 1, 0, 'l'},
-    {"m", 1, 0, 'm'},
-    {"model", 1, 0, 'o'},
-    {"explore", 1, 0, 'x'},
-    {"planner", 1, 0, 'p'},
-    {"combo", 1, 0, 'c'},
-    {"nmodels", 1, 0, '#'},
-    {"reltrans", 0, 0, 't'},
-    {"abstrans", 0, 0, '0'},
-    {"seed", 1, 0, 's'},
-    {"agent", 1, 0, 'q'},
-    {"prints", 0, 0, 'd'},
-    {"nstates", 1, 0, 'w'},
-    {"k", 1, 0, 'k'},
-    {"filename", 1, 0, 'f'},
-    {"history", 1, 0, 'y'},
-    {"b", 1, 0, 'b'},
-    {"v", 1, 0, 'v'},
-    {"n", 1, 0, 'n'},
-
-    {"env", 1, 0, 1},
-    {"deterministic", 0, 0, 2},
-    {"stochastic", 0, 0, 3},
-    {"delay", 1, 0, 4},
-    {"nsectors", 1, 0, 5},
-    {"nstocks", 1, 0, 6},
-    {"lag", 0, 0, 7},
-    {"nolag", 0, 0, 8},
-    {"highvar", 0, 0, 11},
-    {"nepisodes", 1, 0, 12},
-    {"rom", 1, 0, 13}
-  };
-
-  bool epsilonChanged = false;
-  bool actrateChanged = false;
-  bool mChanged = false;
-  bool bvnChanged = false;
-  bool lambdaChanged = false;
-
-  while(-1 != (ch = getopt_long_only(argc, argv, optflags, long_options, &option_index))) {
-    switch(ch) {
-
-    case 'g':
-      discountfactor = std::atof(optarg);
-      cout << "discountfactor: " << discountfactor << endl;
-      break;
-
-    case 'e':
-      epsilonChanged = true;
-      epsilon = std::atof(optarg);
-      cout << "epsilon: " << epsilon << endl;
-      break;
-
-    case 'y':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          history = std::atoi(optarg);
-          cout << "history: " << history << endl;
-        } else {
-          cout << "--history is not a valid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'k':
-      {
-        if (strcmp(agentType, "dyna") == 0){
-          k = std::atoi(optarg);
-          cout << "k: " << k << endl;
-        } else {
-          cout << "--k is only a valid option for the Dyna agent" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'f':
-      filename = optarg;
-      cout << "policy filename: " <<  filename << endl;
-      break;
-
-    case 'a':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          alpha = std::atof(optarg);
-          cout << "alpha: " << alpha << endl;
-        } else {
-          cout << "--alpha option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'i':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          initialvalue = std::atof(optarg);
-          cout << "initialvalue: " << initialvalue << endl;
-        } else {
-          cout << "--initialvalue option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'r':
-      {
-        actrateChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          actrate = std::atof(optarg);
-          cout << "actrate: " << actrate << endl;
-        } else {
-          cout << "Model-free methods do not require an action rate" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'l':
-      {
-        lambdaChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0 || strcmp(agentType, "sarsa") == 0){
-          lambda = std::atof(optarg);
-          cout << "lambda: " << lambda << endl;
-        } else {
-          cout << "--lambda option is invalid for this agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'm':
-      {
-        mChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          M = std::atoi(optarg);
-          cout << "M: " << M << endl;
-        } else {
-          cout << "--M option only useful for model-based agents, not " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'o':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          if (strcmp(optarg, "tabular") == 0) modelType = RMAX;
-          else if (strcmp(optarg, "tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "texplore") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "c45tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "m5tree") == 0) modelType = M5ALLMULTI;
-          if (strcmp(agentType, "rmax") == 0 && modelType != RMAX){
-            cout << "R-Max should use tabular model" << endl;
-            exit(-1);
-          }
-        } else {
-          cout << "Model-free methods do not need a model, --model option does nothing for this agent type" << endl;
-          exit(-1);
-        }
-        cout << "model: " << modelNames[modelType] << endl;
-        break;
-      }
-
-    case 'x':
-      {
-        if (strcmp(optarg, "unknown") == 0) exploreType = EXPLORE_UNKNOWN;
-        else if (strcmp(optarg, "greedy") == 0) exploreType = GREEDY;
-        else if (strcmp(optarg, "epsilongreedy") == 0) exploreType = EPSILONGREEDY;
-        else if (strcmp(optarg, "unvisitedstates") == 0) exploreType = UNVISITED_BONUS;
-        else if (strcmp(optarg, "unvisitedactions") == 0) exploreType = UNVISITED_ACT_BONUS;
-        else if (strcmp(optarg, "variancenovelty") == 0) exploreType = DIFF_AND_NOVEL_BONUS;
-        if (strcmp(agentType, "rmax") == 0 && exploreType != EXPLORE_UNKNOWN){
-          cout << "R-Max should use \"--explore unknown\" exploration" << endl;
-          exit(-1);
-        }
-        else if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0 && (exploreType != GREEDY && exploreType != EPSILONGREEDY)) {
-          cout << "Model free methods must use either greedy or epsilon-greedy exploration!" << endl;
-          exploreType = EPSILONGREEDY;
-          exit(-1);
-        }
-        cout << "explore: " << exploreNames[exploreType] << endl;
-        break;
-      }
-
-    case 'p':
-      {
-        if (strcmp(optarg, "vi") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "valueiteration") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "policyiteration") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "pi") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "sweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "prioritizedsweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "uct") == 0) plannerType = ET_UCT_ACTUAL;
-        else if (strcmp(optarg, "paralleluct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtimeuct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtime-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "parallel-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "delayeduct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayed-uct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayedparalleluct") == 0) plannerType = POMDP_PAR_ETUCT;
-        else if (strcmp(optarg, "delayed-parallel-uct") == 0) plannerType = POMDP_PAR_ETUCT;
-        if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0){
-          cout << "Model-free methods do not require planners, --planner option does nothing with this agent" << endl;
-          exit(-1);
-        }
-        if (strcmp(agentType, "rmax") == 0 && plannerType != VALUE_ITERATION){
-          cout << "Typical implementation of R-Max would use value iteration, but another planner type is ok" << endl;
-        }
-        cout << "planner: " << plannerNames[plannerType] << endl;
-        break;
-      }
-
-    case 'c':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          if (strcmp(optarg, "average") == 0) predType = AVERAGE;
-          else if (strcmp(optarg, "weighted") == 0) predType = WEIGHTAVG;
-          else if (strcmp(optarg, "best") == 0) predType = BEST;
-          else if (strcmp(optarg, "separate") == 0) predType = SEPARATE;
-          cout << "predType: " << comboNames[predType] << endl;
-        } else {
-          cout << "--combo is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '#':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          nmodels = std::atoi(optarg);
-          cout << "nmodels: " << nmodels << endl;
-        } else {
-          cout << "--nmodels is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        if (nmodels < 1){
-          cout << "nmodels must be > 0" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 't':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = true;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--reltrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '0':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = false;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--abstrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 's':
-      seed = std::atoi(optarg);
-      cout << "seed: " << seed << endl;
-      break;
-
-    case 'q':
-      // already processed this one
-      cout << "agent: " << agentType << endl;
-      break;
-
-    case 'd':
-      PRINTS = true;
-      break;
-
-    case 'w':
-      nstates = std::atoi(optarg);
-      cout << "nstates for discretization: " << nstates << endl;
-      break;
-
-    case 'v':
-    case 'b':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          v = std::atof(optarg);
-          cout << "v coefficient (variance bonus): " << v << endl;
-        }
-        else {
-          cout << "--v and --b are invalid options for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'n':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          n = std::atof(optarg);
-          cout << "n coefficient (novelty bonus): " << n << endl;
-        }
-        else {
-          cout << "--n is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 2:
-      stochastic = false;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 11:
-      {
-        if (strcmp(envType, "fuelworld") == 0){
-          highvar = true;
-          cout << "fuel world fuel cost variation: " << highvar << endl;
-        } else {
-          cout << "--highvar is only a valid option for the fuelworld domain." << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 3:
-      stochastic = true;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 4:
-      {
-        if (strcmp(envType, "mcar") == 0 || strcmp(envType, "tworooms") == 0){
-          delay = std::atoi(optarg);
-          cout << "delay steps: " << delay << endl;
-        } else {
-          cout << "--delay option is only valid for the mcar and tworooms domains" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 5:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nsectors = std::atoi(optarg);
-          cout << "nsectors: " << nsectors << endl;
-        } else {
-          cout << "--nsectors option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 6:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nstocks = std::atoi(optarg);
-          cout << "nstocks: " << nstocks << endl;
-        } else {
-          cout << "--nstocks option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 7:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = true;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--lag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 8:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = false;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--nolag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 1:
-      // already processed this one
-      cout << "env: " << envType << endl;
-      break;
-
-    case 12:
-      NUMEPISODES = std::atoi(optarg);
-      cout << "Num Episodes: " << NUMEPISODES << endl;
-      break;
-
-    case 13:
-      // rom case, already processed
-      break;
-
-    case 'h':
-    case '?':
-    case 0:
-    default:
-      displayHelp();
-      break;
-    }
-  }
-
-  // default back to greedy if no coefficients
-  if (exploreType == DIFF_AND_NOVEL_BONUS && v == 0 && n == 0)
-    exploreType = GREEDY;
-
-  // check for conflicting options
-  // changed epsilon but not doing epsilon greedy exploration
-  if (epsilonChanged && exploreType != EPSILONGREEDY){
-    cout << "No reason to change epsilon when not using epsilon-greedy exploration" << endl;
-    exit(-1);
-  }
-
-  // set history value but not doing uct w/history planner
-  if (history > 0 && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set history higher than 0 if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set action rate but not doing real-time planner
-  if (actrateChanged && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set lambda but not doing uct (lambda)
-  if (lambdaChanged && (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0) && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set n/v/b but not doing that diff_novel exploration
-  if (bvnChanged && exploreType != DIFF_AND_NOVEL_BONUS){
-    cout << "No reason to set n or v if not doing variance & novelty exploration" << endl;
-    exit(-1);
-  }
-
-  // set combo other than best but only doing 1 model
-  if (predType != BEST && nmodels == 1){
-    cout << "No reason to have model combo other than best with nmodels = 1" << endl;
-    exit(-1);
-  }
-
-  // set M but not doing explore unknown
-  if (mChanged && exploreType != EXPLORE_UNKNOWN){
-    cout << "No reason to set M if not doing R-max style Explore Unknown exploration" << endl;
-    exit(-1);
-  }
-
-  if (PRINTS){
-    if (stochastic)
-      cout << "Stohastic\n";
-    else
-      cout << "Deterministic\n";
-  }
-
-  Random rng(1 + seed);
-
-  // Construct environment here.
-  Arcade* e;
-  e = new Arcade(romPath);
-
-/*
-  if (strcmp(envType, "cartpole") == 0){
-    if (PRINTS) cout << "Environment: Cart Pole\n";
-    e = new CartPole(rng, stochastic);
-  }
-
-  else if (strcmp(envType, "mcar") == 0){
-    if (PRINTS) cout << "Environment: Mountain Car\n";
-    e = new MountainCar(rng, stochastic, false, delay);
-  }
-
-  // taxi
-  else if (strcmp(envType, "taxi") == 0){
-    if (PRINTS) cout << "Environment: Taxi\n";
-    e = new Taxi(rng, stochastic);
-  }
-
-  // Light World
-  else if (strcmp(envType, "lightworld") == 0){
-    if (PRINTS) cout << "Environment: Light World\n";
-    e = new LightWorld(rng, stochastic, 4);
-  }
-
-  // two rooms
-  else if (strcmp(envType, "tworooms") == 0){
-    if (PRINTS) cout << "Environment: TwoRooms\n";
-    e = new TwoRooms(rng, stochastic, true, delay, false);
-  }
-
-  // car vel, 2 to 7
-  else if (strcmp(envType, "car2to7") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 2 to 7 m/s\n";
-    e = new RobotCarVel(rng, false, true, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, 7 to 2
-  else if (strcmp(envType, "car7to2") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 7 to 2 m/s\n";
-    e = new RobotCarVel(rng, false, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, random vels
-  else if (strcmp(envType, "carrandom") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity Random Velocities\n";
-    e = new RobotCarVel(rng, true, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 48;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-
-  // four rooms
-  else if (strcmp(envType, "fourrooms") == 0){
-    if (PRINTS) cout << "Environment: FourRooms\n";
-    e = new FourRooms(rng, stochastic, true, false);
-  }
-
-  // four rooms with energy level
-  else if (strcmp(envType, "energy") == 0){
-    if (PRINTS) cout << "Environment: EnergyRooms\n";
-    e = new EnergyRooms(rng, stochastic, true, false);
-  }
-
-  // gridworld with fuel (fuel stations on top and bottom with random costs)
-  else if (strcmp(envType, "fuelworld") == 0){
-    if (PRINTS) cout << "Environment: FuelWorld\n";
-    e = new FuelRooms(rng, highvar, stochastic);
-  }
-
-  // stocks
-  else if (strcmp(envType, "stocks") == 0){
-    if (PRINTS) cout << "Enironment: Stocks with " << nsectors
-                     << " sectors and " << nstocks << " stocks\n";
-    e = new Stocks(rng, stochastic, nsectors, nstocks);
-  }
-
-  else {
-    std::cerr << "Invalid env type" << endl;
-    exit(-1);
-  }
-*/
-  const int numactions = e->getNumActions(); // Most agents will need this?
-
-  std::vector<float> minValues;
-  std::vector<float> maxValues;
-  e->getMinMaxFeatures(&minValues, &maxValues);
-  bool episodic = e->isEpisodic();
-  std::vector<ModelSpecification> modelSpecs = e->getModelSpecs();
-  std::vector<int> statesPerDim;
-  e->getDiscretization(&statesPerDim);
-
-  cout << "Environment is ";
-  if (!episodic) cout << "NOT ";
-  cout << "episodic." << endl;
-
-  // lets just check this for now
-  for (unsigned i = 0; i < minValues.size(); i++){
-    if (PRINTS) cout << "Feat " << i << " min: " << minValues[i]
-                     << " max: " << maxValues[i] << endl;
-  }
-
-  // get max/min reward for the domain
-  float rMax = 0.0;
-  float rMin = -1.0;
-
-  e->getMinMaxReward(&rMin, &rMax);
-  float rRange = rMax - rMin;
-  if (PRINTS) cout << "Min Reward: " << rMin
-                   << ", Max Reward: " << rMax << endl;
-
-  // set rmax as a bonus for certain exploration types
-  if (rMax <= 0.0 && (exploreType == TWO_MODE_PLUS_R ||
-                      exploreType == CONTINUOUS_BONUS_R ||
-                      exploreType == CONTINUOUS_BONUS ||
-                      exploreType == THRESHOLD_BONUS_R)){
-    rMax = 1.0;
-  }
-
-
-  float rsum = 0;
-
-  if (statesPerDim.size() == 0){
-    cout << "set statesPerDim to " << nstates << " for all dim" << endl;
-    statesPerDim.resize(minValues.size(), nstates);
-  }
-
-  for (unsigned j = 0; j < NUMTRIALS; ++j) {
-
-    // Construct agent here.
-    Agent* agent;
-
-    if (strcmp(agentType, "qlearner") == 0){
-      if (PRINTS) cout << "Agent: QLearner" << endl;
-      agent = new QLearner(numactions,
-                           discountfactor,
-                           initialvalue, //0.0, // initialvalue
-                           alpha, // alpha
-                           epsilon, // epsilon
-                           rng);
-    }
-
-    else if (strcmp(agentType, "dyna") == 0){
-      if (PRINTS) cout << "Agent: Dyna" << endl;
-      agent = new Dyna(numactions,
-                       discountfactor,
-                       initialvalue, //0.0, // initialvalue
-                       alpha, // alpha
-                       k, // k
-                       epsilon, // epsilon
-                       rng);
-    }
-
-    else if (strcmp(agentType, "sarsa") == 0){
-      if (PRINTS) cout << "Agent: SARSA" << endl;
-      agent = new Sarsa(numactions,
-                        discountfactor,
-                        initialvalue, //0.0, // initialvalue
-                        alpha, // alpha
-                        epsilon, // epsilon
-                        lambda,
-                        rng);
-    }
-
-    else if (strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") || strcmp(agentType, "texplore")){
-      if (PRINTS) cout << "Agent: Model Based" << endl;
-      agent = new ModelBasedAgent(numactions,
-                                  discountfactor,
-                                  rMax, rRange,
-                                  modelType,
-                                  exploreType,
-                                  predType,
-                                  nmodels,
-                                  plannerType,
-                                  epsilon, // epsilon
-                                  lambda,
-                                  (1.0/actrate), //0.1, //0.1, //0.01, // max time
-                                  M,
-                                  minValues, maxValues, modelSpecs,
-                                  statesPerDim,//0,
-                                  history, v, n,
-                                  deptrans, reltrans, featPct, stochastic, episodic,
-                                  rng);
-    }
-
-    else if (strcmp(agentType, "savedpolicy") == 0){
-      if (PRINTS) cout << "Agent: Saved Policy" << endl;
-      agent = new SavedPolicy(numactions,filename);
-    }
-
-    else {
-      std::cerr << "ERROR: Invalid agent type" << endl;
-      exit(-1);
-    }
-
-    // start discrete agent if we're discretizing (if nstates > 0 and not agent type 'c')
-    int totalStates = 1;
-    Agent* a2 = agent;
-    // not for model based when doing continuous model
-    if (nstates > 0 && (modelType != M5ALLMULTI || strcmp(agentType, "qlearner") == 0)){
-      int totalStates = powf(nstates,minValues.size());
-      if (PRINTS) cout << "Discretize with " << nstates << ", total: " << totalStates << endl;
-      agent = new DiscretizationAgent(nstates, a2,
-                                      minValues, maxValues, PRINTS);
-    }
-    else {
-      totalStates = 1;
-      for (unsigned i = 0; i < minValues.size(); i++){
-        int range = 1+maxValues[i] - minValues[i];
-        totalStates *= range;
-      }
-      if (PRINTS) cout << "No discretization, total: " << totalStates << endl;
-    }
-
-    // before we start, seed the agent with some experiences
-    agent->seedExp(e->getSeedings());
-
-    // STEP BY STEP DOMAIN
-    if (!episodic){
-
-      // performance tracking
-      float sum = 0;
-      int steps = 0;
-      float trialSum = 0.0;
-
-      int a = 0;
-      float r = 0;
-
-      //////////////////////////////////
-      // non-episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i){
-
-        std::vector<float> es = e->sensation();
-
-        // first step
-        if (i == 0){
-
-          // first action
-          a = agent->first_action(es);
-          r = e->apply(a);
-
-        } else {
-          // next action
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-        }
-
-        // update performance
-        sum += r;
-        ++steps;
-
-        std::cerr << r << endl;
-
-      }
-      ///////////////////////////////////
-
-      rsum += sum;
-      trialSum += sum;
-      if (PRINTS) cout << "Rsum(trial " << j << "): " << trialSum << " Avg: "
-                       << (rsum / (float)(j+1))<< endl;
-
-    }
-
-    // EPISODIC DOMAINS
-    else {
-      ofstream scoreFile;
-
-      time_t now = time(0);
-      struct tm tstruct;
-      char buff[80];
-      tstruct = *localtime(&now);
-      strftime(buff, sizeof(buff), "%m.%d.%Y\n%H.%M.%S\n", &tstruct);
-      
-      cerr << buff;
-
-      for (unsigned i = 0; i < argc; i++) {
-          cerr << argv[i] << " ";
-      }
-      cerr << endl << endl;
-      cerr << e->getEnvironmentDescription();
-      for (unsigned i = 0; i < modelSpecs.size() - 3; i++) {
-          cerr << i << ": " << modelNames[modelSpecs[i].modelType] << endl;
-      }
-      cerr << "REWARD: " << modelNames[modelSpecs[modelSpecs.size() - 2].modelType] << endl;
-      cerr << "TERMINAL: " << modelNames[modelSpecs[modelSpecs.size() - 1].modelType] << endl << endl;
-
-      FILE *hostname = popen("hostname", "r");
-      char hostbuffer[200];
-      while (fgets(hostbuffer, sizeof(hostbuffer) - 1, hostname) != NULL) {
-          cerr << hostbuffer;
-      }
-      pclose(hostname);
-
-      FILE *lscpu = popen("lscpu", "r");
-      char lscpubuffer[1024];
-      while (fgets(lscpubuffer, sizeof(lscpubuffer) - 1, lscpu) != NULL) {
-          cerr << lscpubuffer;
-      }
-      pclose(lscpu);
-
-      FILE *meminfo = popen("grep \"Mem\" /proc/meminfo", "r");
-      char meminfobuffer[200];
-      while (fgets(meminfobuffer, sizeof(meminfobuffer) - 1, meminfo) != NULL) {
-          cerr << meminfobuffer;
-      }
-      pclose(meminfo);
-
-      cerr << endl << endl;
-      cerr << "score\t#steps\t#invld" << endl;
-
-      //////////////////////////////////
-      // episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i) {
-
-        // performance tracking
-        float sum = 0;
-        int steps = 0;
-        int invalidStates = 0;
-
-        // first action
-        std::vector<float> es = e->sensation();
-        std::vector<float> lastValid = es;
-        int a = agent->first_action(es);
-        float r = e->apply(a);
-
-        // update performance
-        sum += r;
-        ++steps;
-				
-        while (!e->terminal() && steps < MAXSTEPS) {
-          // perform an action
-          es = e->sensation();
-          if (e->invalidStateChange(a)) {
-              a = agent->next_action(r, lastValid);
-              ++invalidStates;
-          }
-          else {
-              a = agent->next_action(r, es);
-              lastValid = es;
-          }
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-        }
- 
-        // terminal/last state
-        if (e->terminal()){
-            agent->last_action(r);
-        }else{
-          if (e->invalidStateChange(a)) {
-            agent->next_action(r, lastValid);
-          }
-          else {
-            agent->next_action(r, e->sensation());
-          }
-        }
-
-        cerr << e->totalScore << "\t" << steps << "\t" << invalidStates << endl;
-        e->reset();
-        //std::cerr << sum << endl;
-        rsum += sum;
-      } 
-    }
-
-    if (NUMTRIALS > 1) delete agent;
-
-  }
-
-  if (PRINTS) cout << "Avg Rsum: " << (rsum / (float)NUMTRIALS) << endl;
-
-} // end main
-				/*
-        while (!e->terminal() && steps < MAXSTEPS) {
-          printf("----------------------------------------------\n");
-
-          // perform an action
-          es = e->sensation();
-					
-          // (cdonahue) don't update learning while invalid
-          bool lostLoc = false;
-          while (e->lostLocation() && !e->terminal())
-          {
-              lostLoc = true;
-              r = e->apply(0);
-              //r = e->apply(1);
-              es = e->sensation();
-          }
-          if (lostLoc) {
-              a = agent->first_action(es);
-              if (e->terminal())
-                  break;
-              continue;
-          }
-
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-        }
-        */
-        /*
-        bool changedRow = false;
-        while (!e->terminal() && steps < MAXSTEPS) {
-
-          // perform an action
-          es = e->sensation();
-          if (changedRow) {
-              a = agent->first_action(es);
-              changedRow = false;
-          }
-          else {
-              a = agent->next_action(r, es);
-          }
-          r = e->apply(a);
-          if (a == 1 || a == 4) {
-              printf("CHANGED ROW");
-              changedRow = true;
-          }
-
-          // update performance info
-          sum += r;
-          ++steps;
-
-        }
-        */
-
diff --git a/src/rl.not.for.condor.cc b/src/rl.not.for.condor.cc
deleted file mode 100755
index 478b172..0000000
--- a/src/rl.not.for.condor.cc
+++ /dev/null
@@ -1,1134 +0,0 @@
-/** \file Main file that starts agents and environments
-    \author Todd Hester
-*/
-
-#include <rl_common/Random.h>
-#include <rl_common/core.hh>
-
-#include <stdio.h>
-#include <string.h>
-#include <sys/time.h>
-#include <iostream>
-#include <fstream>
-
-//////////////////
-// Environments //
-//////////////////
-#include <rl_env/Arcade.hh>
-#include <rl_env/RobotCarVel.hh>
-#include <rl_env/fourrooms.hh>
-#include <rl_env/tworooms.hh>
-#include <rl_env/taxi.hh>
-#include <rl_env/FuelRooms.hh>
-#include <rl_env/stocks.hh>
-#include <rl_env/energyrooms.hh>
-#include <rl_env/MountainCar.hh>
-#include <rl_env/CartPole.hh>
-#include <rl_env/LightWorld.hh>
-
-
-////////////
-// Agents //
-////////////
-#include <rl_agent/QLearner.hh>
-#include <rl_agent/ModelBasedAgent.hh>
-#include <rl_agent/DiscretizationAgent.hh>
-#include <rl_agent/SavedPolicy.hh>
-#include <rl_agent/Dyna.hh>
-#include <rl_agent/Sarsa.hh>
-
-#include <vector>
-#include <sstream>
-#include <iostream>
-
-#include <getopt.h>
-#include <stdlib.h>
-
-unsigned NUMEPISODES = 1000; //10; //200; //500; //200;
-const unsigned NUMTRIALS = 1; //30; //30; //5; //30; //30; //50
-unsigned MAXSTEPS = 1000; // per episode
-bool PRINTS = false;
-
-
-void displayHelp(){
-  cout << "\n Call experiment --agent type --env type [options]\n";
-  cout << "Agent types: qlearner sarsa modelbased rmax texplore dyna savedpolicy\n";
-  cout << "Env types: taxi tworooms fourrooms energy fuelworld mcar cartpole car2to7 car7to2 carrandom stocks lightworld\n";
-
-  cout << "\n Agent Options:\n";
-  cout << "--gamma value (discount factor between 0 and 1)\n";
-  cout << "--epsilon value (epsilon for epsilon-greedy exploration)\n";
-  cout << "--alpha value (learning rate alpha)\n";
-  cout << "--initialvalue value (initial q values)\n";
-  cout << "--actrate value (action selection rate (Hz))\n";
-  cout << "--lamba value (lamba for eligibility traces)\n";
-  cout << "--m value (parameter for R-Max)\n";
-  cout << "--k value (For Dyna: # of model based updates to do between each real world update)\n";
-  cout << "--history value (# steps of history to use for planning with delay)\n";
-  cout << "--filename file (file to load saved policy from for savedpolicy agent)\n";
-  cout << "--model type (tabular,tree,m5tree)\n";
-  cout << "--planner type (vi,pi,sweeping,uct,parallel-uct,delayed-uct,delayed-parallel-uct)\n";
-  cout << "--explore type (unknown,greedy,epsilongreedy,variancenovelty)\n";
-  cout << "--combo type (average,best,separate)\n";
-  cout << "--nmodels value (# of models)\n";
-  cout << "--nstates value (optionally discretize domain into value # of states on each feature)\n";
-  cout << "--reltrans (learn relative transitions)\n";
-  cout << "--abstrans (learn absolute transitions)\n";
-  cout << "--v value (For TEXPLORE: b/v coefficient for rewarding state-actions where models disagree)\n";
-  cout << "--n value (For TEXPLORE: n coefficient for rewarding state-actions which are novel)\n";
-
-  cout << "\n Env Options:\n";
-  cout << "--deterministic (deterministic version of domain)\n";
-  cout << "--stochastic (stochastic version of domain)\n";
-  cout << "--delay value (# steps of action delay (for mcar and tworooms)\n";
-  cout << "--lag (turn on brake lag for car driving domain)\n";
-  cout << "--highvar (have variation fuel costs in Fuel World)\n";
-  cout << "--nsectors value (# sectors for stocks domain)\n";
-  cout << "--nstocks value (# stocks for stocks domain)\n";
-  cout << "--rom path (path to ROM for Arcade env)\n";
-
-  cout << "\n--prints (turn on debug printing of actions/rewards)\n";
-  cout << "--nepisodes value (# of episodes to run (1000 default)\n";
-  cout << "--seed value (integer seed for random number generator)\n";
-
-  cout << "\n For more info, see: http://www.ros.org/wiki/rl_experiment\n";
-
-  exit(-1);
-
-}
-
-
-int main(int argc, char **argv) {
-
-  // default params for env and agent
-  char* agentType = NULL;
-  char* envType = NULL;
-  char* romPath = NULL;
-  char* modelTypeString = NULL;
-  float discountfactor = 0.99;
-  float epsilon = 0.1;
-  float alpha = 0.3;
-  float initialvalue = 0.0;
-  float actrate = 10.0;
-  float lambda = 0.1;
-  int M = 5;
-  int modelType = C45TREE;
-  int exploreType = GREEDY;
-  int predType = BEST;
-  int plannerType = PAR_ETUCT_ACTUAL;
-  int nmodels = 1;
-  bool reltrans = true;
-  bool deptrans = false;
-  float v = 0;
-  float n = 0;
-  float featPct = 0.2;
-  int nstates = 0;
-  int k = 1000;
-  char *filename = NULL;
-  bool stochastic = true;
-  int nstocks = 3;
-  int nsectors = 3;
-  int delay = 0;
-  bool lag = false;
-  bool highvar = false;
-  int history = 0;
-  int seed = 1;
-  // change some of these parameters based on command line args
-
-  // parse agent type
-  bool gotAgent = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--agent") == 0){
-      gotAgent = true;
-      agentType = argv[i+1];
-    }
-  }
-  if (!gotAgent) {
-    cout << "--agent type  option is required" << endl;
-    displayHelp();
-  }
-
-  // set some default options for rmax or texplore
-  if (strcmp(agentType, "rmax") == 0){
-    modelType = RMAX;
-    exploreType = EXPLORE_UNKNOWN;
-    predType = BEST;
-    plannerType = VALUE_ITERATION;
-    nmodels = 1;
-    reltrans = false;
-    M = 5;
-    history = 0;
-  } else if (strcmp(agentType, "texplore") == 0){
-    modelType = C45TREE;
-    exploreType = DIFF_AND_NOVEL_BONUS;
-    v = 0;
-    n = 0;
-    predType = AVERAGE;
-    plannerType = PAR_ETUCT_ACTUAL;
-    nmodels = 5;
-    reltrans = true;
-    M = 0;
-    history = 0;
-  }
-
-  // parse env type
-  /*
-  bool gotEnv = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--env") == 0){
-      gotEnv = true;
-      envType = argv[i+1];
-    }
-  }
-  if (!gotEnv) {
-    cout << "--env type  option is required" << endl;
-    displayHelp();
-  }
-  */
-
-  // parse ROM path
-  bool gotRom = false;
-  for (int i = 1; i < argc-1; i++) {
-    if (strcmp(argv[i], "--rom") == 0){
-      gotRom = true;
-      romPath = argv[i+1];
-    }
-  }
-  if (!gotRom) {
-    cout << "--rom PATH required when env is arcade" << endl;
-    displayHelp();
-  }
-
-  // parse other arguments
-  char ch;
-  const char* optflags = "geairlmoxpcn:";
-  int option_index = 0;
-  static struct option long_options[] = {
-    {"gamma", 1, 0, 'g'},
-    {"discountfactor", 1, 0, 'g'},
-    {"epsilon", 1, 0, 'e'},
-    {"alpha", 1, 0, 'a'},
-    {"initialvalue", 1, 0, 'i'},
-    {"actrate", 1, 0, 'r'},
-    {"lambda", 1, 0, 'l'},
-    {"m", 1, 0, 'm'},
-    {"model", 1, 0, 'o'},
-    {"explore", 1, 0, 'x'},
-    {"planner", 1, 0, 'p'},
-    {"combo", 1, 0, 'c'},
-    {"nmodels", 1, 0, '#'},
-    {"reltrans", 0, 0, 't'},
-    {"abstrans", 0, 0, '0'},
-    {"seed", 1, 0, 's'},
-    {"agent", 1, 0, 'q'},
-    {"prints", 0, 0, 'd'},
-    {"nstates", 1, 0, 'w'},
-    {"k", 1, 0, 'k'},
-    {"filename", 1, 0, 'f'},
-    {"history", 1, 0, 'y'},
-    {"b", 1, 0, 'b'},
-    {"v", 1, 0, 'v'},
-    {"n", 1, 0, 'n'},
-
-    {"env", 1, 0, 1},
-    {"deterministic", 0, 0, 2},
-    {"stochastic", 0, 0, 3},
-    {"delay", 1, 0, 4},
-    {"nsectors", 1, 0, 5},
-    {"nstocks", 1, 0, 6},
-    {"lag", 0, 0, 7},
-    {"nolag", 0, 0, 8},
-    {"highvar", 0, 0, 11},
-    {"nepisodes", 1, 0, 12},
-    {"rom", 1, 0, 13}
-  };
-
-  bool epsilonChanged = false;
-  bool actrateChanged = false;
-  bool mChanged = false;
-  bool bvnChanged = false;
-  bool lambdaChanged = false;
-
-  while(-1 != (ch = getopt_long_only(argc, argv, optflags, long_options, &option_index))) {
-    switch(ch) {
-
-    case 'g':
-      discountfactor = std::atof(optarg);
-      cout << "discountfactor: " << discountfactor << endl;
-      break;
-
-    case 'e':
-      epsilonChanged = true;
-      epsilon = std::atof(optarg);
-      cout << "epsilon: " << epsilon << endl;
-      break;
-
-    case 'y':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          history = std::atoi(optarg);
-          cout << "history: " << history << endl;
-        } else {
-          cout << "--history is not a valid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'k':
-      {
-        if (strcmp(agentType, "dyna") == 0){
-          k = std::atoi(optarg);
-          cout << "k: " << k << endl;
-        } else {
-          cout << "--k is only a valid option for the Dyna agent" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'f':
-      filename = optarg;
-      cout << "policy filename: " <<  filename << endl;
-      break;
-
-    case 'a':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          alpha = std::atof(optarg);
-          cout << "alpha: " << alpha << endl;
-        } else {
-          cout << "--alpha option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'i':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          initialvalue = std::atof(optarg);
-          cout << "initialvalue: " << initialvalue << endl;
-        } else {
-          cout << "--initialvalue option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'r':
-      {
-        actrateChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          actrate = std::atof(optarg);
-          cout << "actrate: " << actrate << endl;
-        } else {
-          cout << "Model-free methods do not require an action rate" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'l':
-      {
-        lambdaChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0 || strcmp(agentType, "sarsa") == 0){
-          lambda = std::atof(optarg);
-          cout << "lambda: " << lambda << endl;
-        } else {
-          cout << "--lambda option is invalid for this agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'm':
-      {
-        mChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          M = std::atoi(optarg);
-          cout << "M: " << M << endl;
-        } else {
-          cout << "--M option only useful for model-based agents, not " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'o':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          if (strcmp(optarg, "tabular") == 0) modelType = RMAX;
-          else if (strcmp(optarg, "tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "texplore") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "c45tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "m5tree") == 0) modelType = M5ALLMULTI;
-          if (strcmp(agentType, "rmax") == 0 && modelType != RMAX){
-            cout << "R-Max should use tabular model" << endl;
-            exit(-1);
-          }
-        } else {
-          cout << "Model-free methods do not need a model, --model option does nothing for this agent type" << endl;
-          exit(-1);
-        }
-        cout << "model: " << modelNames[modelType] << endl;
-        break;
-      }
-
-    case 'x':
-      {
-        if (strcmp(optarg, "unknown") == 0) exploreType = EXPLORE_UNKNOWN;
-        else if (strcmp(optarg, "greedy") == 0) exploreType = GREEDY;
-        else if (strcmp(optarg, "epsilongreedy") == 0) exploreType = EPSILONGREEDY;
-        else if (strcmp(optarg, "unvisitedstates") == 0) exploreType = UNVISITED_BONUS;
-        else if (strcmp(optarg, "unvisitedactions") == 0) exploreType = UNVISITED_ACT_BONUS;
-        else if (strcmp(optarg, "variancenovelty") == 0) exploreType = DIFF_AND_NOVEL_BONUS;
-        if (strcmp(agentType, "rmax") == 0 && exploreType != EXPLORE_UNKNOWN){
-          cout << "R-Max should use \"--explore unknown\" exploration" << endl;
-          exit(-1);
-        }
-        else if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0 && (exploreType != GREEDY && exploreType != EPSILONGREEDY)) {
-          cout << "Model free methods must use either greedy or epsilon-greedy exploration!" << endl;
-          exploreType = EPSILONGREEDY;
-          exit(-1);
-        }
-        cout << "explore: " << exploreNames[exploreType] << endl;
-        break;
-      }
-
-    case 'p':
-      {
-        if (strcmp(optarg, "vi") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "valueiteration") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "policyiteration") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "pi") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "sweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "prioritizedsweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "uct") == 0) plannerType = ET_UCT_ACTUAL;
-        else if (strcmp(optarg, "paralleluct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtimeuct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtime-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "parallel-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "delayeduct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayed-uct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayedparalleluct") == 0) plannerType = POMDP_PAR_ETUCT;
-        else if (strcmp(optarg, "delayed-parallel-uct") == 0) plannerType = POMDP_PAR_ETUCT;
-        if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0){
-          cout << "Model-free methods do not require planners, --planner option does nothing with this agent" << endl;
-          exit(-1);
-        }
-        if (strcmp(agentType, "rmax") == 0 && plannerType != VALUE_ITERATION){
-          cout << "Typical implementation of R-Max would use value iteration, but another planner type is ok" << endl;
-        }
-        cout << "planner: " << plannerNames[plannerType] << endl;
-        break;
-      }
-
-    case 'c':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          if (strcmp(optarg, "average") == 0) predType = AVERAGE;
-          else if (strcmp(optarg, "weighted") == 0) predType = WEIGHTAVG;
-          else if (strcmp(optarg, "best") == 0) predType = BEST;
-          else if (strcmp(optarg, "separate") == 0) predType = SEPARATE;
-          cout << "predType: " << comboNames[predType] << endl;
-        } else {
-          cout << "--combo is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '#':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          nmodels = std::atoi(optarg);
-          cout << "nmodels: " << nmodels << endl;
-        } else {
-          cout << "--nmodels is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        if (nmodels < 1){
-          cout << "nmodels must be > 0" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 't':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = true;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--reltrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '0':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = false;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--abstrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 's':
-      seed = std::atoi(optarg);
-      cout << "seed: " << seed << endl;
-      break;
-
-    case 'q':
-      // already processed this one
-      cout << "agent: " << agentType << endl;
-      break;
-
-    case 'd':
-      PRINTS = true;
-      break;
-
-    case 'w':
-      nstates = std::atoi(optarg);
-      cout << "nstates for discretization: " << nstates << endl;
-      break;
-
-    case 'v':
-    case 'b':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          v = std::atof(optarg);
-          cout << "v coefficient (variance bonus): " << v << endl;
-        }
-        else {
-          cout << "--v and --b are invalid options for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'n':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          n = std::atof(optarg);
-          cout << "n coefficient (novelty bonus): " << n << endl;
-        }
-        else {
-          cout << "--n is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 2:
-      stochastic = false;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 11:
-      {
-        if (strcmp(envType, "fuelworld") == 0){
-          highvar = true;
-          cout << "fuel world fuel cost variation: " << highvar << endl;
-        } else {
-          cout << "--highvar is only a valid option for the fuelworld domain." << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 3:
-      stochastic = true;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 4:
-      {
-        if (strcmp(envType, "mcar") == 0 || strcmp(envType, "tworooms") == 0){
-          delay = std::atoi(optarg);
-          cout << "delay steps: " << delay << endl;
-        } else {
-          cout << "--delay option is only valid for the mcar and tworooms domains" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 5:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nsectors = std::atoi(optarg);
-          cout << "nsectors: " << nsectors << endl;
-        } else {
-          cout << "--nsectors option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 6:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nstocks = std::atoi(optarg);
-          cout << "nstocks: " << nstocks << endl;
-        } else {
-          cout << "--nstocks option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 7:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = true;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--lag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 8:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = false;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--nolag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 1:
-      // already processed this one
-      cout << "env: " << envType << endl;
-      break;
-
-    case 12:
-      NUMEPISODES = std::atoi(optarg);
-      cout << "Num Episodes: " << NUMEPISODES << endl;
-      break;
-
-    case 13:
-      // rom case, already processed
-      break;
-
-    case 'h':
-    case '?':
-    case 0:
-    default:
-      displayHelp();
-      break;
-    }
-  }
-
-  // default back to greedy if no coefficients
-  if (exploreType == DIFF_AND_NOVEL_BONUS && v == 0 && n == 0)
-    exploreType = GREEDY;
-
-  // check for conflicting options
-  // changed epsilon but not doing epsilon greedy exploration
-  if (epsilonChanged && exploreType != EPSILONGREEDY){
-    cout << "No reason to change epsilon when not using epsilon-greedy exploration" << endl;
-    exit(-1);
-  }
-
-  // set history value but not doing uct w/history planner
-  if (history > 0 && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set history higher than 0 if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set action rate but not doing real-time planner
-  if (actrateChanged && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set lambda but not doing uct (lambda)
-  if (lambdaChanged && (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0) && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set n/v/b but not doing that diff_novel exploration
-  if (bvnChanged && exploreType != DIFF_AND_NOVEL_BONUS){
-    cout << "No reason to set n or v if not doing variance & novelty exploration" << endl;
-    exit(-1);
-  }
-
-  // set combo other than best but only doing 1 model
-  if (predType != BEST && nmodels == 1){
-    cout << "No reason to have model combo other than best with nmodels = 1" << endl;
-    exit(-1);
-  }
-
-  // set M but not doing explore unknown
-  if (mChanged && exploreType != EXPLORE_UNKNOWN){
-    cout << "No reason to set M if not doing R-max style Explore Unknown exploration" << endl;
-    exit(-1);
-  }
-
-  if (PRINTS){
-    if (stochastic)
-      cout << "Stohastic\n";
-    else
-      cout << "Deterministic\n";
-  }
-
-  Random rng(1 + seed);
-
-  // Construct environment here.
-  Arcade* e;
-  e = new Arcade(romPath);
-
-/*
-  if (strcmp(envType, "cartpole") == 0){
-    if (PRINTS) cout << "Environment: Cart Pole\n";
-    e = new CartPole(rng, stochastic);
-  }
-
-  else if (strcmp(envType, "mcar") == 0){
-    if (PRINTS) cout << "Environment: Mountain Car\n";
-    e = new MountainCar(rng, stochastic, false, delay);
-  }
-
-  // taxi
-  else if (strcmp(envType, "taxi") == 0){
-    if (PRINTS) cout << "Environment: Taxi\n";
-    e = new Taxi(rng, stochastic);
-  }
-
-  // Light World
-  else if (strcmp(envType, "lightworld") == 0){
-    if (PRINTS) cout << "Environment: Light World\n";
-    e = new LightWorld(rng, stochastic, 4);
-  }
-
-  // two rooms
-  else if (strcmp(envType, "tworooms") == 0){
-    if (PRINTS) cout << "Environment: TwoRooms\n";
-    e = new TwoRooms(rng, stochastic, true, delay, false);
-  }
-
-  // car vel, 2 to 7
-  else if (strcmp(envType, "car2to7") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 2 to 7 m/s\n";
-    e = new RobotCarVel(rng, false, true, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, 7 to 2
-  else if (strcmp(envType, "car7to2") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 7 to 2 m/s\n";
-    e = new RobotCarVel(rng, false, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, random vels
-  else if (strcmp(envType, "carrandom") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity Random Velocities\n";
-    e = new RobotCarVel(rng, true, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 48;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-
-  // four rooms
-  else if (strcmp(envType, "fourrooms") == 0){
-    if (PRINTS) cout << "Environment: FourRooms\n";
-    e = new FourRooms(rng, stochastic, true, false);
-  }
-
-  // four rooms with energy level
-  else if (strcmp(envType, "energy") == 0){
-    if (PRINTS) cout << "Environment: EnergyRooms\n";
-    e = new EnergyRooms(rng, stochastic, true, false);
-  }
-
-  // gridworld with fuel (fuel stations on top and bottom with random costs)
-  else if (strcmp(envType, "fuelworld") == 0){
-    if (PRINTS) cout << "Environment: FuelWorld\n";
-    e = new FuelRooms(rng, highvar, stochastic);
-  }
-
-  // stocks
-  else if (strcmp(envType, "stocks") == 0){
-    if (PRINTS) cout << "Enironment: Stocks with " << nsectors
-                     << " sectors and " << nstocks << " stocks\n";
-    e = new Stocks(rng, stochastic, nsectors, nstocks);
-  }
-
-  else {
-    std::cerr << "Invalid env type" << endl;
-    exit(-1);
-  }
-*/
-  const int numactions = e->getNumActions(); // Most agents will need this?
-
-  std::vector<float> minValues;
-  std::vector<float> maxValues;
-  e->getMinMaxFeatures(&minValues, &maxValues);
-  bool episodic = e->isEpisodic();
-  std::vector<ModelSpecification> modelSpecs = e->getModelSpecs();
-  std::vector<int> statesPerDim;
-  e->getDiscretization(&statesPerDim);
-
-  cout << "Environment is ";
-  if (!episodic) cout << "NOT ";
-  cout << "episodic." << endl;
-
-  // lets just check this for now
-  for (unsigned i = 0; i < minValues.size(); i++){
-    if (PRINTS) cout << "Feat " << i << " min: " << minValues[i]
-                     << " max: " << maxValues[i] << endl;
-  }
-
-  // get max/min reward for the domain
-  float rMax = 0.0;
-  float rMin = -1.0;
-
-  e->getMinMaxReward(&rMin, &rMax);
-  float rRange = rMax - rMin;
-  if (PRINTS) cout << "Min Reward: " << rMin
-                   << ", Max Reward: " << rMax << endl;
-
-  // set rmax as a bonus for certain exploration types
-  if (rMax <= 0.0 && (exploreType == TWO_MODE_PLUS_R ||
-                      exploreType == CONTINUOUS_BONUS_R ||
-                      exploreType == CONTINUOUS_BONUS ||
-                      exploreType == THRESHOLD_BONUS_R)){
-    rMax = 1.0;
-  }
-
-
-  float rsum = 0;
-
-  if (statesPerDim.size() == 0){
-    cout << "set statesPerDim to " << nstates << " for all dim" << endl;
-    statesPerDim.resize(minValues.size(), nstates);
-  }
-
-  for (unsigned j = 0; j < NUMTRIALS; ++j) {
-
-    // Construct agent here.
-    Agent* agent;
-
-    if (strcmp(agentType, "qlearner") == 0){
-      if (PRINTS) cout << "Agent: QLearner" << endl;
-      agent = new QLearner(numactions,
-                           discountfactor,
-                           initialvalue, //0.0, // initialvalue
-                           alpha, // alpha
-                           epsilon, // epsilon
-                           rng);
-    }
-
-    else if (strcmp(agentType, "dyna") == 0){
-      if (PRINTS) cout << "Agent: Dyna" << endl;
-      agent = new Dyna(numactions,
-                       discountfactor,
-                       initialvalue, //0.0, // initialvalue
-                       alpha, // alpha
-                       k, // k
-                       epsilon, // epsilon
-                       rng);
-    }
-
-    else if (strcmp(agentType, "sarsa") == 0){
-      if (PRINTS) cout << "Agent: SARSA" << endl;
-      agent = new Sarsa(numactions,
-                        discountfactor,
-                        initialvalue, //0.0, // initialvalue
-                        alpha, // alpha
-                        epsilon, // epsilon
-                        lambda,
-                        rng);
-    }
-
-    else if (strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") || strcmp(agentType, "texplore")){
-      if (PRINTS) cout << "Agent: Model Based" << endl;
-      agent = new ModelBasedAgent(numactions,
-                                  discountfactor,
-                                  rMax, rRange,
-                                  modelType,
-                                  exploreType,
-                                  predType,
-                                  nmodels,
-                                  plannerType,
-                                  epsilon, // epsilon
-                                  lambda,
-                                  (1.0/actrate), //0.1, //0.1, //0.01, // max time
-                                  M,
-                                  minValues, maxValues, modelSpecs,
-                                  statesPerDim,//0,
-                                  history, v, n,
-                                  deptrans, reltrans, featPct, stochastic, episodic,
-                                  rng);
-    }
-
-    else if (strcmp(agentType, "savedpolicy") == 0){
-      if (PRINTS) cout << "Agent: Saved Policy" << endl;
-      agent = new SavedPolicy(numactions,filename);
-    }
-
-    else {
-      std::cerr << "ERROR: Invalid agent type" << endl;
-      exit(-1);
-    }
-
-    // start discrete agent if we're discretizing (if nstates > 0 and not agent type 'c')
-    int totalStates = 1;
-    Agent* a2 = agent;
-    // not for model based when doing continuous model
-    if (nstates > 0 && (modelType != M5ALLMULTI || strcmp(agentType, "qlearner") == 0)){
-      int totalStates = powf(nstates,minValues.size());
-      if (PRINTS) cout << "Discretize with " << nstates << ", total: " << totalStates << endl;
-      agent = new DiscretizationAgent(nstates, a2,
-                                      minValues, maxValues, PRINTS);
-    }
-    else {
-      totalStates = 1;
-      for (unsigned i = 0; i < minValues.size(); i++){
-        int range = 1+maxValues[i] - minValues[i];
-        totalStates *= range;
-      }
-      if (PRINTS) cout << "No discretization, total: " << totalStates << endl;
-    }
-
-    // before we start, seed the agent with some experiences
-    agent->seedExp(e->getSeedings());
-
-    // STEP BY STEP DOMAIN
-    if (!episodic){
-
-      // performance tracking
-      float sum = 0;
-      int steps = 0;
-      float trialSum = 0.0;
-
-      int a = 0;
-      float r = 0;
-
-      //////////////////////////////////
-      // non-episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i){
-
-        std::vector<float> es = e->sensation();
-
-        // first step
-        if (i == 0){
-
-          // first action
-          a = agent->first_action(es);
-          r = e->apply(a);
-
-        } else {
-          // next action
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-        }
-
-        // update performance
-        sum += r;
-        ++steps;
-
-        std::cerr << r << endl;
-
-      }
-      ///////////////////////////////////
-
-      rsum += sum;
-      trialSum += sum;
-      if (PRINTS) cout << "Rsum(trial " << j << "): " << trialSum << " Avg: "
-                       << (rsum / (float)(j+1))<< endl;
-
-    }
-
-    // EPISODIC DOMAINS
-    else {
-      ofstream scoreFile;
-
-      time_t now = time(0);
-      struct tm tstruct;
-      char buff[80];
-      tstruct = *localtime(&now);
-      strftime(buff, sizeof(buff), "%m.%d.%Y..%H.%M.%S", &tstruct);
-      
-      char pathBuffer[100] = {};
-      sprintf(pathBuffer, "scores/%s.scores", buff);
-
-      scoreFile.open(pathBuffer, ios::app);
-
-      for (unsigned i = 0; i < argc; i++) {
-          scoreFile << argv[i] << " ";
-      }
-      scoreFile << endl << endl;
-      scoreFile << e->getEnvironmentDescription();
-      for (unsigned i = 0; i < modelSpecs.size() - 3; i++) {
-          scoreFile << i << ": " << modelNames[modelSpecs[i].modelType] << endl;
-      }
-      scoreFile << "REWARD: " << modelNames[modelSpecs[modelSpecs.size() - 2].modelType] << endl;
-      scoreFile << "TERMINAL: " << modelNames[modelSpecs[modelSpecs.size() - 1].modelType] << endl << endl;
-
-      FILE *hostname = popen("hostname", "r");
-      char hostbuffer[200];
-      while (fgets(hostbuffer, sizeof(hostbuffer) - 1, hostname) != NULL) {
-          scoreFile << hostbuffer;
-      }
-      pclose(hostname);
-
-      FILE *lscpu = popen("lscpu", "r");
-      char lscpubuffer[1024];
-      while (fgets(lscpubuffer, sizeof(lscpubuffer) - 1, lscpu) != NULL) {
-          scoreFile << lscpubuffer;
-      }
-      pclose(lscpu);
-
-      FILE *meminfo = popen("grep \"Mem\" /proc/meminfo", "r");
-      char meminfobuffer[200];
-      while (fgets(meminfobuffer, sizeof(meminfobuffer) - 1, meminfo) != NULL) {
-          scoreFile << meminfobuffer;
-      }
-      pclose(meminfo);
-
-      scoreFile << endl << endl;
-      scoreFile << "score\t#steps\t#invld" << endl;
-
-      //////////////////////////////////
-      // episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i) {
-
-        // performance tracking
-        float sum = 0;
-        int steps = 0;
-        int invalidStates = 0;
-
-        // first action
-        std::vector<float> es = e->sensation();
-        int a = agent->first_action(es);
-        float r = e->apply(a);
-
-        // update performance
-        sum += r;
-        ++steps;
-				
-        while (!e->terminal() && steps < MAXSTEPS) {
-          // perform an action
-          es = e->sensation();
-          if (e->invalidStateChange(a)) {
-              a = agent->first_action(es);
-              ++invalidStates;
-          }
-          else {
-              a = agent->next_action(r, es);
-          }
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-        }
- 
-        // terminal/last state
-        if (e->terminal()){
-          agent->last_action(r);
-        }else{
-          agent->next_action(r, e->sensation());
-        }
-
-        scoreFile << e->totalScore << "\t" << steps << "\t" << invalidStates << endl;
-        e->reset();
-        //std::cerr << sum << endl;
-        rsum += sum;
-      } 
-      scoreFile.close();
-    }
-
-    if (NUMTRIALS > 1) delete agent;
-
-  }
-
-  if (PRINTS) cout << "Avg Rsum: " << (rsum / (float)NUMTRIALS) << endl;
-
-} // end main
-				/*
-        while (!e->terminal() && steps < MAXSTEPS) {
-          printf("----------------------------------------------\n");
-
-          // perform an action
-          es = e->sensation();
-					
-          // (cdonahue) don't update learning while invalid
-          bool lostLoc = false;
-          while (e->lostLocation() && !e->terminal())
-          {
-              lostLoc = true;
-              r = e->apply(0);
-              //r = e->apply(1);
-              es = e->sensation();
-          }
-          if (lostLoc) {
-              a = agent->first_action(es);
-              if (e->terminal())
-                  break;
-              continue;
-          }
-
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-        }
-        */
-        /*
-        bool changedRow = false;
-        while (!e->terminal() && steps < MAXSTEPS) {
-
-          // perform an action
-          es = e->sensation();
-          if (changedRow) {
-              a = agent->first_action(es);
-              changedRow = false;
-          }
-          else {
-              a = agent->next_action(r, es);
-          }
-          r = e->apply(a);
-          if (a == 1 || a == 4) {
-              printf("CHANGED ROW");
-              changedRow = true;
-          }
-
-          // update performance info
-          sum += r;
-          ++steps;
-
-        }
-        */
-
diff --git a/src/rl.original.cc b/src/rl.original.cc
deleted file mode 100755
index 1a71eb6..0000000
--- a/src/rl.original.cc
+++ /dev/null
@@ -1,1001 +0,0 @@
-/** \file Main file that starts agents and environments
-    \author Todd Hester
-*/
-
-#include <rl_common/Random.h>
-#include <rl_common/core.hh>
-
-#include <stdio.h>
-#include <string.h>
-#include <sys/time.h>
-
-//////////////////
-// Environments //
-//////////////////
-#include <rl_env/RobotCarVel.hh>
-#include <rl_env/fourrooms.hh>
-#include <rl_env/tworooms.hh>
-#include <rl_env/taxi.hh>
-#include <rl_env/FuelRooms.hh>
-#include <rl_env/stocks.hh>
-#include <rl_env/energyrooms.hh>
-#include <rl_env/MountainCar.hh>
-#include <rl_env/CartPole.hh>
-#include <rl_env/LightWorld.hh>
-
-
-////////////
-// Agents //
-////////////
-#include <rl_agent/QLearner.hh>
-#include <rl_agent/ModelBasedAgent.hh>
-#include <rl_agent/DiscretizationAgent.hh>
-#include <rl_agent/SavedPolicy.hh>
-#include <rl_agent/Dyna.hh>
-#include <rl_agent/Sarsa.hh>
-
-
-
-#include <vector>
-#include <sstream>
-#include <iostream>
-
-#include <getopt.h>
-#include <stdlib.h>
-
-unsigned NUMEPISODES = 1000; //10; //200; //500; //200;
-const unsigned NUMTRIALS = 1; //30; //30; //5; //30; //30; //50
-unsigned MAXSTEPS = 1000; // per episode
-bool PRINTS = false;
-
-
-void displayHelp(){
-  cout << "\n Call experiment --agent type --env type [options]\n";
-  cout << "Agent types: qlearner sarsa modelbased rmax texplore dyna savedpolicy\n";
-  cout << "Env types: taxi tworooms fourrooms energy fuelworld mcar cartpole car2to7 car7to2 carrandom stocks lightworld\n";
-
-  cout << "\n Agent Options:\n";
-  cout << "--gamma value (discount factor between 0 and 1)\n";
-  cout << "--epsilon value (epsilon for epsilon-greedy exploration)\n";
-  cout << "--alpha value (learning rate alpha)\n";
-  cout << "--initialvalue value (initial q values)\n";
-  cout << "--actrate value (action selection rate (Hz))\n";
-  cout << "--lamba value (lamba for eligibility traces)\n";
-  cout << "--m value (parameter for R-Max)\n";
-  cout << "--k value (For Dyna: # of model based updates to do between each real world update)\n";
-  cout << "--history value (# steps of history to use for planning with delay)\n";
-  cout << "--filename file (file to load saved policy from for savedpolicy agent)\n";
-  cout << "--model type (tabular,tree,m5tree)\n";
-  cout << "--planner type (vi,pi,sweeping,uct,parallel-uct,delayed-uct,delayed-parallel-uct)\n";
-  cout << "--explore type (unknown,greedy,epsilongreedy,variancenovelty)\n";
-  cout << "--combo type (average,best,separate)\n";
-  cout << "--nmodels value (# of models)\n";
-  cout << "--nstates value (optionally discretize domain into value # of states on each feature)\n";
-  cout << "--reltrans (learn relative transitions)\n";
-  cout << "--abstrans (learn absolute transitions)\n";
-  cout << "--v value (For TEXPLORE: b/v coefficient for rewarding state-actions where models disagree)\n";
-  cout << "--n value (For TEXPLORE: n coefficient for rewarding state-actions which are novel)\n";
-
-  cout << "\n Env Options:\n";
-  cout << "--deterministic (deterministic version of domain)\n";
-  cout << "--stochastic (stochastic version of domain)\n";
-  cout << "--delay value (# steps of action delay (for mcar and tworooms)\n";
-  cout << "--lag (turn on brake lag for car driving domain)\n";
-  cout << "--highvar (have variation fuel costs in Fuel World)\n";
-  cout << "--nsectors value (# sectors for stocks domain)\n";
-  cout << "--nstocks value (# stocks for stocks domain)\n";
-
-  cout << "\n--prints (turn on debug printing of actions/rewards)\n";
-  cout << "--nepisodes value (# of episodes to run (1000 default)\n";
-  cout << "--seed value (integer seed for random number generator)\n";
-
-  cout << "\n For more info, see: http://www.ros.org/wiki/rl_experiment\n";
-
-  exit(-1);
-
-}
-
-
-int main(int argc, char **argv) {
-
-  // default params for env and agent
-  char* agentType = NULL;
-  char* envType = NULL;
-  float discountfactor = 0.99;
-  float epsilon = 0.1;
-  float alpha = 0.3;
-  float initialvalue = 0.0;
-  float actrate = 10.0;
-  float lambda = 0.1;
-  int M = 5;
-  int modelType = C45TREE;
-  int exploreType = GREEDY;
-  int predType = BEST;
-  int plannerType = PAR_ETUCT_ACTUAL;
-  int nmodels = 1;
-  bool reltrans = true;
-  bool deptrans = false;
-  float v = 0;
-  float n = 0;
-  float featPct = 0.2;
-  int nstates = 0;
-  int k = 1000;
-  char *filename = NULL;
-  bool stochastic = true;
-  int nstocks = 3;
-  int nsectors = 3;
-  int delay = 0;
-  bool lag = false;
-  bool highvar = false;
-  int history = 0;
-  int seed = 1;
-  // change some of these parameters based on command line args
-
-  // parse agent type
-  bool gotAgent = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--agent") == 0){
-      gotAgent = true;
-      agentType = argv[i+1];
-    }
-  }
-  if (!gotAgent) {
-    cout << "--agent type  option is required" << endl;
-    displayHelp();
-  }
-
-  // set some default options for rmax or texplore
-  if (strcmp(agentType, "rmax") == 0){
-    modelType = RMAX;
-    exploreType = EXPLORE_UNKNOWN;
-    predType = BEST;
-    plannerType = VALUE_ITERATION;
-    nmodels = 1;
-    reltrans = false;
-    M = 5;
-    history = 0;
-  } else if (strcmp(agentType, "texplore") == 0){
-    modelType = C45TREE;
-    exploreType = DIFF_AND_NOVEL_BONUS;
-    v = 0;
-    n = 0;
-    predType = AVERAGE;
-    plannerType = PAR_ETUCT_ACTUAL;
-    nmodels = 5;
-    reltrans = true;
-    M = 0;
-    history = 0;
-  }
-
-  // parse env type
-  bool gotEnv = false;
-  for (int i = 1; i < argc-1; i++){
-    if (strcmp(argv[i], "--env") == 0){
-      gotEnv = true;
-      envType = argv[i+1];
-    }
-  }
-  if (!gotEnv) {
-    cout << "--env type  option is required" << endl;
-    displayHelp();
-  }
-
-  // parse other arguments
-  char ch;
-  const char* optflags = "geairlmoxpcn:";
-  int option_index = 0;
-  static struct option long_options[] = {
-    {"gamma", 1, 0, 'g'},
-    {"discountfactor", 1, 0, 'g'},
-    {"epsilon", 1, 0, 'e'},
-    {"alpha", 1, 0, 'a'},
-    {"initialvalue", 1, 0, 'i'},
-    {"actrate", 1, 0, 'r'},
-    {"lambda", 1, 0, 'l'},
-    {"m", 1, 0, 'm'},
-    {"model", 1, 0, 'o'},
-    {"explore", 1, 0, 'x'},
-    {"planner", 1, 0, 'p'},
-    {"combo", 1, 0, 'c'},
-    {"nmodels", 1, 0, '#'},
-    {"reltrans", 0, 0, 't'},
-    {"abstrans", 0, 0, '0'},
-    {"seed", 1, 0, 's'},
-    {"agent", 1, 0, 'q'},
-    {"prints", 0, 0, 'd'},
-    {"nstates", 1, 0, 'w'},
-    {"k", 1, 0, 'k'},
-    {"filename", 1, 0, 'f'},
-    {"history", 1, 0, 'y'},
-    {"b", 1, 0, 'b'},
-    {"v", 1, 0, 'v'},
-    {"n", 1, 0, 'n'},
-
-    {"env", 1, 0, 1},
-    {"deterministic", 0, 0, 2},
-    {"stochastic", 0, 0, 3},
-    {"delay", 1, 0, 4},
-    {"nsectors", 1, 0, 5},
-    {"nstocks", 1, 0, 6},
-    {"lag", 0, 0, 7},
-    {"nolag", 0, 0, 8},
-    {"highvar", 0, 0, 11},
-    {"nepisodes", 1, 0, 12}
-
-  };
-
-  bool epsilonChanged = false;
-  bool actrateChanged = false;
-  bool mChanged = false;
-  bool bvnChanged = false;
-  bool lambdaChanged = false;
-
-  while(-1 != (ch = getopt_long_only(argc, argv, optflags, long_options, &option_index))) {
-    switch(ch) {
-
-    case 'g':
-      discountfactor = std::atof(optarg);
-      cout << "discountfactor: " << discountfactor << endl;
-      break;
-
-    case 'e':
-      epsilonChanged = true;
-      epsilon = std::atof(optarg);
-      cout << "epsilon: " << epsilon << endl;
-      break;
-
-    case 'y':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          history = std::atoi(optarg);
-          cout << "history: " << history << endl;
-        } else {
-          cout << "--history is not a valid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'k':
-      {
-        if (strcmp(agentType, "dyna") == 0){
-          k = std::atoi(optarg);
-          cout << "k: " << k << endl;
-        } else {
-          cout << "--k is only a valid option for the Dyna agent" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'f':
-      filename = optarg;
-      cout << "policy filename: " <<  filename << endl;
-      break;
-
-    case 'a':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          alpha = std::atof(optarg);
-          cout << "alpha: " << alpha << endl;
-        } else {
-          cout << "--alpha option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'i':
-      {
-        if (strcmp(agentType, "qlearner") == 0 || strcmp(agentType, "dyna") == 0 || strcmp(agentType, "sarsa") == 0){
-          initialvalue = std::atof(optarg);
-          cout << "initialvalue: " << initialvalue << endl;
-        } else {
-          cout << "--initialvalue option is only valid for Q-Learning, Dyna, and Sarsa" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'r':
-      {
-        actrateChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          actrate = std::atof(optarg);
-          cout << "actrate: " << actrate << endl;
-        } else {
-          cout << "Model-free methods do not require an action rate" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'l':
-      {
-        lambdaChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0 || strcmp(agentType, "sarsa") == 0){
-          lambda = std::atof(optarg);
-          cout << "lambda: " << lambda << endl;
-        } else {
-          cout << "--lambda option is invalid for this agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'm':
-      {
-        mChanged = true;
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          M = std::atoi(optarg);
-          cout << "M: " << M << endl;
-        } else {
-          cout << "--M option only useful for model-based agents, not " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'o':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0){
-          if (strcmp(optarg, "tabular") == 0) modelType = RMAX;
-          else if (strcmp(optarg, "tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "texplore") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "c45tree") == 0) modelType = C45TREE;
-          else if (strcmp(optarg, "m5tree") == 0) modelType = M5ALLMULTI;
-          if (strcmp(agentType, "rmax") == 0 && modelType != RMAX){
-            cout << "R-Max should use tabular model" << endl;
-            exit(-1);
-          }
-        } else {
-          cout << "Model-free methods do not need a model, --model option does nothing for this agent type" << endl;
-          exit(-1);
-        }
-        cout << "model: " << modelNames[modelType] << endl;
-        break;
-      }
-
-    case 'x':
-      {
-        if (strcmp(optarg, "unknown") == 0) exploreType = EXPLORE_UNKNOWN;
-        else if (strcmp(optarg, "greedy") == 0) exploreType = GREEDY;
-        else if (strcmp(optarg, "epsilongreedy") == 0) exploreType = EPSILONGREEDY;
-        else if (strcmp(optarg, "unvisitedstates") == 0) exploreType = UNVISITED_BONUS;
-        else if (strcmp(optarg, "unvisitedactions") == 0) exploreType = UNVISITED_ACT_BONUS;
-        else if (strcmp(optarg, "variancenovelty") == 0) exploreType = DIFF_AND_NOVEL_BONUS;
-        if (strcmp(agentType, "rmax") == 0 && exploreType != EXPLORE_UNKNOWN){
-          cout << "R-Max should use \"--explore unknown\" exploration" << endl;
-          exit(-1);
-        }
-        else if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0 && (exploreType != GREEDY && exploreType != EPSILONGREEDY)) {
-          cout << "Model free methods must use either greedy or epsilon-greedy exploration!" << endl;
-          exploreType = EPSILONGREEDY;
-          exit(-1);
-        }
-        cout << "explore: " << exploreNames[exploreType] << endl;
-        break;
-      }
-
-    case 'p':
-      {
-        if (strcmp(optarg, "vi") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "valueiteration") == 0) plannerType = VALUE_ITERATION;
-        else if (strcmp(optarg, "policyiteration") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "pi") == 0) plannerType = POLICY_ITERATION;
-        else if (strcmp(optarg, "sweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "prioritizedsweeping") == 0) plannerType = PRI_SWEEPING;
-        else if (strcmp(optarg, "uct") == 0) plannerType = ET_UCT_ACTUAL;
-        else if (strcmp(optarg, "paralleluct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtimeuct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "realtime-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "parallel-uct") == 0) plannerType = PAR_ETUCT_ACTUAL;
-        else if (strcmp(optarg, "delayeduct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayed-uct") == 0) plannerType = POMDP_ETUCT;
-        else if (strcmp(optarg, "delayedparalleluct") == 0) plannerType = POMDP_PAR_ETUCT;
-        else if (strcmp(optarg, "delayed-parallel-uct") == 0) plannerType = POMDP_PAR_ETUCT;
-        if (strcmp(agentType, "texplore") != 0 && strcmp(agentType, "modelbased") != 0 && strcmp(agentType, "rmax") != 0){
-          cout << "Model-free methods do not require planners, --planner option does nothing with this agent" << endl;
-          exit(-1);
-        }
-        if (strcmp(agentType, "rmax") == 0 && plannerType != VALUE_ITERATION){
-          cout << "Typical implementation of R-Max would use value iteration, but another planner type is ok" << endl;
-        }
-        cout << "planner: " << plannerNames[plannerType] << endl;
-        break;
-      }
-
-    case 'c':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          if (strcmp(optarg, "average") == 0) predType = AVERAGE;
-          else if (strcmp(optarg, "weighted") == 0) predType = WEIGHTAVG;
-          else if (strcmp(optarg, "best") == 0) predType = BEST;
-          else if (strcmp(optarg, "separate") == 0) predType = SEPARATE;
-          cout << "predType: " << comboNames[predType] << endl;
-        } else {
-          cout << "--combo is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '#':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          nmodels = std::atoi(optarg);
-          cout << "nmodels: " << nmodels << endl;
-        } else {
-          cout << "--nmodels is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        if (nmodels < 1){
-          cout << "nmodels must be > 0" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 't':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = true;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--reltrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case '0':
-      {
-        if (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0){
-          reltrans = false;
-          cout << "reltrans: " << reltrans << endl;
-        } else {
-          cout << "--abstrans is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 's':
-      seed = std::atoi(optarg);
-      cout << "seed: " << seed << endl;
-      break;
-
-    case 'q':
-      // already processed this one
-      cout << "agent: " << agentType << endl;
-      break;
-
-    case 'd':
-      PRINTS = true;
-      break;
-
-    case 'w':
-      nstates = std::atoi(optarg);
-      cout << "nstates for discretization: " << nstates << endl;
-      break;
-
-    case 'v':
-    case 'b':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          v = std::atof(optarg);
-          cout << "v coefficient (variance bonus): " << v << endl;
-        }
-        else {
-          cout << "--v and --b are invalid options for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 'n':
-      {
-        bvnChanged = true;
-        if (strcmp(agentType, "texplore") == 0){
-          n = std::atof(optarg);
-          cout << "n coefficient (novelty bonus): " << n << endl;
-        }
-        else {
-          cout << "--n is an invalid option for agent: " << agentType << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 2:
-      stochastic = false;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 11:
-      {
-        if (strcmp(envType, "fuelworld") == 0){
-          highvar = true;
-          cout << "fuel world fuel cost variation: " << highvar << endl;
-        } else {
-          cout << "--highvar is only a valid option for the fuelworld domain." << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 3:
-      stochastic = true;
-      cout << "stochastic: " << stochastic << endl;
-      break;
-
-    case 4:
-      {
-        if (strcmp(envType, "mcar") == 0 || strcmp(envType, "tworooms") == 0){
-          delay = std::atoi(optarg);
-          cout << "delay steps: " << delay << endl;
-        } else {
-          cout << "--delay option is only valid for the mcar and tworooms domains" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 5:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nsectors = std::atoi(optarg);
-          cout << "nsectors: " << nsectors << endl;
-        } else {
-          cout << "--nsectors option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 6:
-      {
-        if (strcmp(envType, "stocks") == 0){
-          nstocks = std::atoi(optarg);
-          cout << "nstocks: " << nstocks << endl;
-        } else {
-          cout << "--nstocks option is only valid for the stocks domain" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 7:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = true;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--lag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 8:
-      {
-        if (strcmp(envType, "car2to7") == 0 || strcmp(envType, "car7to2") == 0 || strcmp(envType, "carrandom") == 0){
-          lag = false;
-          cout << "lag: " << lag << endl;
-        } else {
-          cout << "--nolag option is only valid for car velocity tasks" << endl;
-          exit(-1);
-        }
-        break;
-      }
-
-    case 1:
-      // already processed this one
-      cout << "env: " << envType << endl;
-      break;
-
-    case 12:
-      NUMEPISODES = std::atoi(optarg);
-      cout << "Num Episodes: " << NUMEPISODES << endl;
-      break;
-
-    case 'h':
-    case '?':
-    case 0:
-    default:
-      displayHelp();
-      break;
-    }
-  }
-
-  // default back to greedy if no coefficients
-  if (exploreType == DIFF_AND_NOVEL_BONUS && v == 0 && n == 0)
-    exploreType = GREEDY;
-
-  // check for conflicting options
-  // changed epsilon but not doing epsilon greedy exploration
-  if (epsilonChanged && exploreType != EPSILONGREEDY){
-    cout << "No reason to change epsilon when not using epsilon-greedy exploration" << endl;
-    exit(-1);
-  }
-
-  // set history value but not doing uct w/history planner
-  if (history > 0 && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set history higher than 0 if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set action rate but not doing real-time planner
-  if (actrateChanged && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set lambda but not doing uct (lambda)
-  if (lambdaChanged && (strcmp(agentType, "texplore") == 0 || strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") == 0) && (plannerType == VALUE_ITERATION || plannerType == POLICY_ITERATION || plannerType == PRI_SWEEPING)){
-    cout << "No reason to set actrate if not using a UCT planner" << endl;
-    exit(-1);
-  }
-
-  // set n/v/b but not doing that diff_novel exploration
-  if (bvnChanged && exploreType != DIFF_AND_NOVEL_BONUS){
-    cout << "No reason to set n or v if not doing variance & novelty exploration" << endl;
-    exit(-1);
-  }
-
-  // set combo other than best but only doing 1 model
-  if (predType != BEST && nmodels == 1){
-    cout << "No reason to have model combo other than best with nmodels = 1" << endl;
-    exit(-1);
-  }
-
-  // set M but not doing explore unknown
-  if (mChanged && exploreType != EXPLORE_UNKNOWN){
-    cout << "No reason to set M if not doing R-max style Explore Unknown exploration" << endl;
-    exit(-1);
-  }
-
-  if (PRINTS){
-    if (stochastic)
-      cout << "Stohastic\n";
-    else
-      cout << "Deterministic\n";
-  }
-
-  Random rng(1 + seed);
-
-  std::vector<int> statesPerDim;
-
-  // Construct environment here.
-  Environment* e;
-
-  if (strcmp(envType, "cartpole") == 0){
-    if (PRINTS) cout << "Environment: Cart Pole\n";
-    e = new CartPole(rng, stochastic);
-  }
-
-  else if (strcmp(envType, "mcar") == 0){
-    if (PRINTS) cout << "Environment: Mountain Car\n";
-    e = new MountainCar(rng, stochastic, false, delay);
-  }
-
-  // taxi
-  else if (strcmp(envType, "taxi") == 0){
-    if (PRINTS) cout << "Environment: Taxi\n";
-    e = new Taxi(rng, stochastic);
-  }
-
-  // Light World
-  else if (strcmp(envType, "lightworld") == 0){
-    if (PRINTS) cout << "Environment: Light World\n";
-    e = new LightWorld(rng, stochastic, 4);
-  }
-
-  // two rooms
-  else if (strcmp(envType, "tworooms") == 0){
-    if (PRINTS) cout << "Environment: TwoRooms\n";
-    e = new TwoRooms(rng, stochastic, true, delay, false);
-  }
-
-  // car vel, 2 to 7
-  else if (strcmp(envType, "car2to7") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 2 to 7 m/s\n";
-    e = new RobotCarVel(rng, false, true, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, 7 to 2
-  else if (strcmp(envType, "car7to2") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity 7 to 2 m/s\n";
-    e = new RobotCarVel(rng, false, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 120;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-  // car vel, random vels
-  else if (strcmp(envType, "carrandom") == 0){
-    if (PRINTS) cout << "Environment: Car Velocity Random Velocities\n";
-    e = new RobotCarVel(rng, true, false, false, lag);
-    statesPerDim.resize(4,0);
-    statesPerDim[0] = 12;
-    statesPerDim[1] = 48;
-    statesPerDim[2] = 4;
-    statesPerDim[3] = 10;
-    MAXSTEPS = 100;
-  }
-
-  // four rooms
-  else if (strcmp(envType, "fourrooms") == 0){
-    if (PRINTS) cout << "Environment: FourRooms\n";
-    e = new FourRooms(rng, stochastic, true, false);
-  }
-
-  // four rooms with energy level
-  else if (strcmp(envType, "energy") == 0){
-    if (PRINTS) cout << "Environment: EnergyRooms\n";
-    e = new EnergyRooms(rng, stochastic, true, false);
-  }
-
-  // gridworld with fuel (fuel stations on top and bottom with random costs)
-  else if (strcmp(envType, "fuelworld") == 0){
-    if (PRINTS) cout << "Environment: FuelWorld\n";
-    e = new FuelRooms(rng, highvar, stochastic);
-  }
-
-  // stocks
-  else if (strcmp(envType, "stocks") == 0){
-    if (PRINTS) cout << "Enironment: Stocks with " << nsectors
-                     << " sectors and " << nstocks << " stocks\n";
-    e = new Stocks(rng, stochastic, nsectors, nstocks);
-  }
-
-  else {
-    std::cerr << "Invalid env type" << endl;
-    exit(-1);
-  }
-
-  const int numactions = e->getNumActions(); // Most agents will need this?
-
-  std::vector<float> minValues;
-  std::vector<float> maxValues;
-  e->getMinMaxFeatures(&minValues, &maxValues);
-  bool episodic = e->isEpisodic();
-
-  cout << "Environment is ";
-  if (!episodic) cout << "NOT ";
-  cout << "episodic." << endl;
-
-  // lets just check this for now
-  for (unsigned i = 0; i < minValues.size(); i++){
-    if (PRINTS) cout << "Feat " << i << " min: " << minValues[i]
-                     << " max: " << maxValues[i] << endl;
-  }
-
-  // get max/min reward for the domain
-  float rMax = 0.0;
-  float rMin = -1.0;
-
-  e->getMinMaxReward(&rMin, &rMax);
-  float rRange = rMax - rMin;
-  if (PRINTS) cout << "Min Reward: " << rMin
-                   << ", Max Reward: " << rMax << endl;
-
-  // set rmax as a bonus for certain exploration types
-  if (rMax <= 0.0 && (exploreType == TWO_MODE_PLUS_R ||
-                      exploreType == CONTINUOUS_BONUS_R ||
-                      exploreType == CONTINUOUS_BONUS ||
-                      exploreType == THRESHOLD_BONUS_R)){
-    rMax = 1.0;
-  }
-
-
-  float rsum = 0;
-
-  if (statesPerDim.size() == 0){
-    cout << "set statesPerDim to " << nstates << " for all dim" << endl;
-    statesPerDim.resize(minValues.size(), nstates);
-  }
-
-  for (unsigned j = 0; j < NUMTRIALS; ++j) {
-
-    // Construct agent here.
-    Agent* agent;
-
-    if (strcmp(agentType, "qlearner") == 0){
-      if (PRINTS) cout << "Agent: QLearner" << endl;
-      agent = new QLearner(numactions,
-                           discountfactor,
-                           initialvalue, //0.0, // initialvalue
-                           alpha, // alpha
-                           epsilon, // epsilon
-                           rng);
-    }
-
-    else if (strcmp(agentType, "dyna") == 0){
-      if (PRINTS) cout << "Agent: Dyna" << endl;
-      agent = new Dyna(numactions,
-                       discountfactor,
-                       initialvalue, //0.0, // initialvalue
-                       alpha, // alpha
-                       k, // k
-                       epsilon, // epsilon
-                       rng);
-    }
-
-    else if (strcmp(agentType, "sarsa") == 0){
-      if (PRINTS) cout << "Agent: SARSA" << endl;
-      agent = new Sarsa(numactions,
-                        discountfactor,
-                        initialvalue, //0.0, // initialvalue
-                        alpha, // alpha
-                        epsilon, // epsilon
-                        lambda,
-                        rng);
-    }
-
-    else if (strcmp(agentType, "modelbased") == 0 || strcmp(agentType, "rmax") || strcmp(agentType, "texplore")){
-      if (PRINTS) cout << "Agent: Model Based" << endl;
-      agent = new ModelBasedAgent(numactions,
-                                  discountfactor,
-                                  rMax, rRange,
-                                  modelType,
-                                  exploreType,
-                                  predType,
-                                  nmodels,
-                                  plannerType,
-                                  epsilon, // epsilon
-                                  lambda,
-                                  (1.0/actrate), //0.1, //0.1, //0.01, // max time
-                                  M,
-                                  minValues, maxValues,
-                                  statesPerDim,//0,
-                                  history, v, n,
-                                  deptrans, reltrans, featPct, stochastic, episodic,
-                                  rng);
-    }
-
-    else if (strcmp(agentType, "savedpolicy") == 0){
-      if (PRINTS) cout << "Agent: Saved Policy" << endl;
-      agent = new SavedPolicy(numactions,filename);
-    }
-
-    else {
-      std::cerr << "ERROR: Invalid agent type" << endl;
-      exit(-1);
-    }
-
-    // start discrete agent if we're discretizing (if nstates > 0 and not agent type 'c')
-    int totalStates = 1;
-    Agent* a2 = agent;
-    // not for model based when doing continuous model
-    if (nstates > 0 && (modelType != M5ALLMULTI || strcmp(agentType, "qlearner") == 0)){
-      int totalStates = powf(nstates,minValues.size());
-      if (PRINTS) cout << "Discretize with " << nstates << ", total: " << totalStates << endl;
-      agent = new DiscretizationAgent(nstates, a2,
-                                      minValues, maxValues, PRINTS);
-    }
-    else {
-      totalStates = 1;
-      for (unsigned i = 0; i < minValues.size(); i++){
-        int range = 1+maxValues[i] - minValues[i];
-        totalStates *= range;
-      }
-      if (PRINTS) cout << "No discretization, total: " << totalStates << endl;
-    }
-
-    // before we start, seed the agent with some experiences
-    agent->seedExp(e->getSeedings());
-
-    // STEP BY STEP DOMAIN
-    if (!episodic){
-
-      // performance tracking
-      float sum = 0;
-      int steps = 0;
-      float trialSum = 0.0;
-
-      int a = 0;
-      float r = 0;
-
-      //////////////////////////////////
-      // non-episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i){
-
-        std::vector<float> es = e->sensation();
-
-        // first step
-        if (i == 0){
-
-          // first action
-          a = agent->first_action(es);
-          r = e->apply(a);
-
-        } else {
-          // next action
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-        }
-
-        // update performance
-        sum += r;
-        ++steps;
-
-        std::cerr << r << endl;
-
-      }
-      ///////////////////////////////////
-
-      rsum += sum;
-      trialSum += sum;
-      if (PRINTS) cout << "Rsum(trial " << j << "): " << trialSum << " Avg: "
-                       << (rsum / (float)(j+1))<< endl;
-
-    }
-
-    // EPISODIC DOMAINS
-    else {
-
-      //////////////////////////////////
-      // episodic
-      //////////////////////////////////
-      for (unsigned i = 0; i < NUMEPISODES; ++i) {
-
-        // performance tracking
-        float sum = 0;
-        int steps = 0;
-
-        // first action
-        std::vector<float> es = e->sensation();
-        int a = agent->first_action(es);
-        float r = e->apply(a);
-
-        // update performance
-        sum += r;
-        ++steps;
-
-        while (!e->terminal() && steps < MAXSTEPS) {
-
-          // perform an action
-          es = e->sensation();
-          a = agent->next_action(r, es);
-          r = e->apply(a);
-
-          // update performance info
-          sum += r;
-          ++steps;
-
-        }
-
-        // terminal/last state
-        if (e->terminal()){
-          agent->last_action(r);
-        }else{
-          agent->next_action(r, e->sensation());
-        }
-
-        e->reset();
-        std::cerr << sum << endl;
-
-        rsum += sum;
-
-      }
-
-    }
-
-    if (NUMTRIALS > 1) delete agent;
-
-  }
-
-  if (PRINTS) cout << "Avg Rsum: " << (rsum / (float)NUMTRIALS) << endl;
-
-} // end main
-
